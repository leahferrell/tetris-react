{"version":3,"sources":["data/shapes.ts","components/block/block.tsx","components/shape/shape.tsx","components/shape-window/shape-window.tsx","state/game/game-slice.ts","data/game.ts","state/grid/grid-generator.ts","state/grid/grid-slice.ts","data/grid.ts","state/shapes/current-slice.ts","state/shapes/hold-slice.ts","state/shapes/shape-generator.ts","state/shapes/next-slice.ts","controllers/game-controller/game-controller.ts","containers/shape-window/shape-window.tsx","controllers/input-controller/touch-controller.ts","components/grid/grid.tsx","containers/grid-container/grid-container.tsx","containers/stats-view/stats-view.tsx","containers/game-view/game-view.tsx","controllers/input-controller/key-press-controller.ts","containers/pause-view/pause-view.tsx","pages/tetris/tetris-page.tsx","App.tsx","state/store.ts","index.tsx"],"names":["BlockColor","ShapeType","availableShapes","L","bitmap","color","Orange","O","Yellow","T","Purple","S","Green","Z","Red","J","Blue","I","Teal","totalNumShapes","Object","keys","length","Block","isGhosted","classNames","Empty","toLowerCase","filter","Boolean","join","className","trimBitmap","trimmedBitmap","removeFirst","removeLast","forEach","row","trimmedBitmapRow","block","index","push","Shape","type","orientation","renderedShape","map","rowIx","renderedRow","isFilled","columnIx","ShapeWindow","title","shape","onTouchStart","initialState","gameOver","level","lines","paused","remainingLines","score","tickInterval","gameSlice","createSlice","name","reducers","removedLines","state","action","countRemovedLines","payload","pause","interval","clearInterval","undefined","createdInterval","actions","generateInitialGrid","numOfRows","numOfColumns","Array","fill","generateEmptyRow","rows","gutterRows","gridSlice","update","currentSlice","move","position","rotate","currentActions","holdSlice","holdActions","generateNextShape","Math","floor","random","nextSlice","nextActions","tick","dispatch","getState","grid","current","next","gutter","useNext","checkCanShapeMove","removeCompleteRows","rowsRemovedCount","newGrid","gridState","renderNewGrid","currentPosition","x","y","incrementedPosition","moveToTheSide","movement","canShapeMove","swapHold","hold","findIndex","completedRowsCount","i","unshift","computeShapeCoordinates","coordinates","yIx","bit","xIx","shapeCoordinates","coordinate","newGridRow","NextShapeWindow","useSelector","HoldShapeWindow","useDispatch","Grid","gridContents","GridContainer","Stat","label","value","StatsView","game","GameView","isPaused","currentInterval","useEffect","setInterval","Fragment","keyPressHandler","ArrowDown","ArrowLeft","ArrowRight","ArrowUp","increment","console","log","p","P","Shift","handleKeyPress","event","handler","key","PauseView","onKeyDown","tabIndex","onClick","TetrisPage","App","basename","path","element","href","target","rel","store","configureStore","reducer","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.52dcb46b.chunk.js","sourcesContent":["export enum BlockColor {\n  Empty,\n  Red,\n  Green,\n  Blue,\n  Purple,\n  Yellow,\n  Teal,\n  Orange\n}\n\nexport enum ShapeType {\n  I,\n  O,\n  T,\n  S,\n  Z,\n  J,\n  L\n}\n\nexport interface ShapeData {\n  bitmap: number[][][],\n  color: BlockColor\n}\n\nexport interface ShapesData {\n  [index: number]: ShapeData\n}\n\nexport const availableShapes: ShapesData = {\n  [ShapeType.L]: {\n    bitmap: [\n      [\n        [0,0,1,0],\n        [1,1,1,0]\n      ],\n      [\n        [1,0,0,0],\n        [1,0,0,0],\n        [1,1,0,0]\n      ],\n      [\n        [1,1,1,0],\n        [1,0,0,0]\n      ],\n      [\n        [0,1,1,0],\n        [0,0,1,0],\n        [0,0,1,0]\n      ]\n    ],\n    color: BlockColor.Orange\n  },\n  [ShapeType.O]: {\n    bitmap: [\n      [\n        [0,1,1,0],\n        [0,1,1,0]\n      ]\n    ],\n    color: BlockColor.Yellow\n  },\n  [ShapeType.T]: {\n    bitmap: [\n      [\n        [0,1,0,0],\n        [1,1,1,0]\n      ],\n      [\n        [0,1,0,0],\n        [0,1,1,0],\n        [0,1,0,0]\n      ],\n      [\n        [1,1,1,0],\n        [0,1,0,0]\n      ],\n      [\n        [0,1,0,0],\n        [1,1,0,0],\n        [0,1,0,0]\n      ]\n    ],\n    color: BlockColor.Purple\n  },\n  [ShapeType.S]: {\n    bitmap: [\n      [\n        [0,1,1,0],\n        [1,1,0,0]\n      ],\n      [\n        [0,1,0,0],\n        [0,1,1,0],\n        [0,0,1,0]\n      ],\n      [\n        [0,1,1,0],\n        [1,1,0,0]\n      ],\n      [\n        [1,0,0,0],\n        [1,1,0,0],\n        [0,1,0,0]\n      ]\n    ],\n    color: BlockColor.Green\n  },\n  [ShapeType.Z]: {\n    bitmap: [\n      [\n        [1,1,0,0],\n        [0,1,1,0]\n      ],\n      [\n        [0,0,1,0],\n        [0,1,1,0],\n        [0,1,0,0]\n      ],\n      [\n        [1,1,0,0],\n        [0,1,1,0]\n      ],\n      [\n        [0,1,0,0],\n        [1,1,0,0],\n        [1,0,0,0]\n      ]\n    ],\n    color: BlockColor.Red\n  },\n  [ShapeType.J]: {\n    bitmap: [\n      [\n        [1,0,0,0],\n        [1,1,1,0]\n      ],\n      [\n        [1,1,0,0],\n        [1,0,0,0],\n        [1,0,0,0]\n      ],\n      [\n        [1,1,1,0],\n        [0,0,1,0]\n      ],\n      [\n        [0,0,1,0],\n        [0,0,1,0],\n        [0,1,1,0]\n      ]\n    ],\n    color: BlockColor.Blue\n  },\n  [ShapeType.I]: {\n    bitmap: [\n      [\n        [1,1,1,1],\n        [0,0,0,0]\n      ],\n      [\n        [0,0,1,0],\n        [0,0,1,0],\n        [0,0,1,0],\n        [0,0,1,0]\n      ],\n      [\n        [1,1,1,1],\n        [0,0,0,0]\n      ],\n      [\n        [0,1,0,0],\n        [0,1,0,0],\n        [0,1,0,0],\n        [0,1,0,0]\n      ]\n    ],\n    color: BlockColor.Teal\n  },\n}\n\nexport const totalNumShapes = Object.keys(availableShapes).length\n","import {ReactElement} from 'react'\n\nimport {BlockColor} from '../../data/shapes'\n\nimport './block.scss'\n\nexport interface BlockProps {\n  isGhosted: boolean,\n  color: BlockColor\n}\n\nconst Block = ({ isGhosted, color }: BlockProps): ReactElement => {\n  const classNames = [\n    'block',\n    BlockColor.Empty !== color && `block--${BlockColor[color].toLowerCase()}`,\n    isGhosted && 'block--ghosted'\n  ].filter( Boolean ).join(' ')\n\n  return (\n    <div className={classNames}/>\n  )\n}\n\nexport default Block\n","import {ReactElement} from 'react'\n\nimport {availableShapes, BlockColor, ShapeType} from '../../data/shapes'\nimport Block from '../block/block'\n\nimport './shape.scss'\n\nexport interface ShapeProps {\n  type: ShapeType,\n  orientation: number\n}\n\nconst Shape = ({type, orientation}: ShapeProps): ReactElement => {\n  if (type == null) {\n    return <div/>\n  }\n\n  const bitmap = trimBitmap(availableShapes[type].bitmap[orientation])\n\n  const renderedShape = bitmap.map((row, rowIx) => {\n    const renderedRow = row.map((isFilled, columnIx) => {\n      return (\n        <Block\n          key={`shape-block-${rowIx}-${columnIx}`}\n          isGhosted={false}\n          color={isFilled? availableShapes[type].color : BlockColor.Empty}\n        />\n      )\n    })\n\n    return (\n      <div className='shape__row' key={`shape-row-${rowIx}`}>\n        {renderedRow}\n      </div>\n    )\n  })\n\n  return (\n    <div className='shape'>{renderedShape}</div>\n  )\n}\n\nconst trimBitmap = (bitmap: number[][]) => {\n  const trimmedBitmap: number[][] = []\n  const removeFirst = bitmap[0][0] === 0 && bitmap[1][0] === 0\n  const removeLast = bitmap[0][bitmap[0].length-1] === 0 && bitmap[1][bitmap[0].length-1] === 0\n\n  bitmap.forEach((row) => {\n    const trimmedBitmapRow: number[] = []\n    row.forEach((block, index) => {\n      if ((index !== 0 || !removeFirst) && (index !== row.length-1 || !removeLast)) {\n        trimmedBitmapRow.push(block)\n      }\n    })\n    trimmedBitmap.push(trimmedBitmapRow)\n  })\n\n\n\n  return trimmedBitmap\n}\n\nexport default Shape\n","import {ReactElement, TouchEventHandler} from 'react'\n\nimport {NullableShapeState} from '../../state/shapes/shape-types'\nimport Shape from '../shape/shape'\n\nimport './shape-window.scss'\n\nexport interface ShapeWindowProps {\n  onTouchStart?: TouchEventHandler | undefined,\n  title: string,\n  shape: NullableShapeState\n}\n\nconst ShapeWindow = ({title, shape, onTouchStart}: ShapeWindowProps): ReactElement => {\n  return (\n    <div onTouchStart={onTouchStart} className=\"shape-window\">\n      <p>{title}</p>\n      {shape && <Shape {...shape} />}\n    </div>\n  )\n}\n\nexport default ShapeWindow\n","import {createSlice, PayloadAction} from '@reduxjs/toolkit'\nimport {TICK_INTERVAL} from '../../data/game'\n\nexport interface GameState {\n  gameOver: boolean,\n  interval?: NodeJS.Timeout,\n  level: number,\n  lines: number,\n  paused: boolean,\n  remainingLines: number,\n  score: number,\n  tickInterval: number\n}\n\nconst initialState: GameState = {\n  gameOver: false,\n  level: 1,\n  lines: 0,\n  paused: true,\n  remainingLines: 10,\n  score: 0,\n  tickInterval: TICK_INTERVAL\n}\n\nexport const gameSlice = createSlice({\n  name: 'game',\n  initialState,\n  reducers: {\n    removedLines: (state: GameState, action: PayloadAction<number>) => {\n      const countRemovedLines = action.payload\n\n      return {\n        ...state,\n        lines: state.lines + countRemovedLines,\n        remainingLines: state.remainingLines - countRemovedLines,\n        score: state.score + (100 * countRemovedLines)\n      }\n    },\n    pause: (state: GameState) => {\n      if (state.interval != null) {\n        clearInterval(state.interval) // TODO: figure out where to put this since this is a side effect\n      }\n\n      return {\n        ...state,\n        interval: undefined,\n        paused: !state.paused\n      }\n    },\n    createdInterval: (state: GameState, action: PayloadAction<NodeJS.Timeout>) => {\n      if (state.interval != null) {\n        clearInterval(state.interval) // TODO: figure out where to put this since this is a side effect\n      }\n\n      return {\n        ...state,\n        interval: action.payload\n      }\n    }\n  }\n})\n\nexport const { pause, removedLines, createdInterval } = gameSlice.actions\n","export const TICK_INTERVAL = 1000 // 1 second\n","import {BlockColor} from '../../data/shapes'\nimport {BlockProps} from '../../components/block/block'\n\nexport const generateInitialGrid = (numOfRows: number, numOfColumns: number): BlockProps[][] => {\n  return new Array<BlockProps[]>(numOfRows).fill(generateEmptyRow(numOfColumns))\n}\n\nexport const generateEmptyRow = (numOfColumns: number): BlockProps[] => {\n  return new Array<BlockProps>(numOfColumns).fill({\n    isGhosted: false,\n    color: BlockColor.Empty\n  })\n}\n","import {createSlice, PayloadAction} from '@reduxjs/toolkit'\n\nimport {BlockProps} from '../../components/block/block'\nimport {TOTAL_COLUMNS, TOTAL_ROWS} from '../../data/grid'\nimport {generateInitialGrid} from './grid-generator'\n\nexport interface GridState {\n  rows: BlockProps[][],\n  gutterRows: BlockProps[][]\n}\n\nconst initialState: GridState = {\n  rows: generateInitialGrid(TOTAL_ROWS, TOTAL_COLUMNS),\n  gutterRows: generateInitialGrid(TOTAL_ROWS, TOTAL_COLUMNS)\n}\n\nexport const gridSlice = createSlice({\n  name: 'grid',\n  initialState,\n  reducers: {\n    update: (state: GridState, action: PayloadAction<GridState>) => {\n      return action.payload\n    }\n  }\n})\n\nexport const { update } = gridSlice.actions\n","export const TOTAL_ROWS = 20\nexport const TOTAL_COLUMNS = 10\n","import {createSlice, PayloadAction} from '@reduxjs/toolkit'\n\nimport {Coordinate, NullableShapeState, ShapeState} from './shape-types'\n\nconst initialState: NullableShapeState = null as NullableShapeState\n\nexport const currentSlice = createSlice({\n  name: 'current',\n  initialState,\n  reducers: {\n    move: (state: NullableShapeState, action: PayloadAction<Coordinate>) => {\n      if (state == null) {\n        return state\n      }\n\n      return {\n        ...state,\n        position: action.payload\n      }\n    },\n    rotate: (state: NullableShapeState) => {\n      if (state == null) {\n        return state\n      }\n\n      return {\n        ...state,\n        orientation: (state.orientation + 1) % 4\n      }\n    },\n    update: (state: NullableShapeState, action: PayloadAction<ShapeState>) => {\n      if (action.payload != null) {\n        return action.payload\n      } else {\n        return state\n      }\n    }\n  }\n})\n\nexport const currentActions = currentSlice.actions\n","import {createSlice, PayloadAction} from '@reduxjs/toolkit'\n\nimport {NullableShapeState, ShapeState} from './shape-types'\n\nconst initialState: NullableShapeState = null as NullableShapeState\n\nexport const holdSlice = createSlice({\n  name: 'hold',\n  initialState,\n  reducers: {\n    update: (state: NullableShapeState, action: PayloadAction<ShapeState>) => {\n      if (action.payload != null) {\n        return action.payload\n      } else {\n        return state\n      }\n    }\n  }\n})\n\nexport const holdActions = holdSlice.actions\n","import {totalNumShapes} from '../../data/shapes'\nimport {ShapeState} from './shape-types'\n\nexport const generateNextShape = (): ShapeState => {\n  const shapeTypeId = Math.floor(Math.random() * totalNumShapes)\n  const shape: ShapeState = {\n    type: shapeTypeId,\n    orientation: 0\n  }\n\n  return shape\n}\n","import {createSlice} from '@reduxjs/toolkit'\n\nimport {ShapeState} from './shape-types'\nimport {generateNextShape} from './shape-generator'\n\nconst initialState: ShapeState = generateNextShape()\n\nexport const nextSlice = createSlice({\n  name: 'next',\n  initialState,\n  reducers: {\n    update: () => {\n      return generateNextShape() // TODO: fix this\n    }\n  }\n})\n\nexport const nextActions = nextSlice.actions\n","import {PayloadAction} from '@reduxjs/toolkit'\n\nimport {BlockProps} from '../../components/block/block'\nimport {TOTAL_COLUMNS, TOTAL_ROWS} from '../../data/grid'\nimport {availableShapes, BlockColor} from '../../data/shapes'\nimport {removedLines} from '../../state/game/game-slice'\nimport {GridState, update} from '../../state/grid/grid-slice'\nimport {currentActions} from '../../state/shapes/current-slice'\nimport {holdActions} from '../../state/shapes/hold-slice'\nimport {nextActions} from '../../state/shapes/next-slice'\nimport {Coordinate, ShapeState} from '../../state/shapes/shape-types'\nimport {AppDispatch, RootState} from '../../state/store'\n\nexport const tick = () => (dispatch: AppDispatch, getState: () => RootState): void | PayloadAction<Coordinate> | PayloadAction => {\n  const { grid, current, next } = getState()\n\n  const gutter = grid.gutterRows\n\n  // check if shape exists?\n  if (current == null) {\n    return useNext(dispatch, next)\n  }\n\n  // check if shape can be rendered\n  const canShapeMove = checkCanShapeMove(gutter, current)\n\n  if (!canShapeMove) {\n    const {rowsRemovedCount, newGrid} = removeCompleteRows(grid.rows)\n    dispatch(removedLines(rowsRemovedCount))\n\n    const gridState: GridState = {\n      rows: newGrid,\n      gutterRows: newGrid\n    }\n    dispatch(update(gridState))\n    return useNext(dispatch, next)\n  }\n\n  // render new grid\n  const gridState: GridState = {\n    rows: renderNewGrid(gutter, current),\n    gutterRows: gutter\n  }\n  dispatch(update(gridState))\n\n  // move down one\n  const currentPosition = current.position || {x: 3, y: 0} // x = (10 - 4) / 2\n  const incrementedPosition = { x: currentPosition.x, y: currentPosition.y + 1 }\n  return dispatch(currentActions.move(incrementedPosition))\n}\n\nexport const moveToTheSide = (movement: number) => (dispatch: AppDispatch, getState: () => RootState): void | PayloadAction => {\n  const { grid, current, next } = getState()\n\n  const gutter = grid.gutterRows\n\n  // check if shape exists?\n  if (current == null) {\n    return useNext(dispatch, next)\n  }\n\n  // move left/right\n  const currentPosition = current.position || {x: 3, y: 0} // x = (10 - 4) / 2\n  const incrementedPosition = { x: currentPosition.x + movement, y: currentPosition.y }\n\n  // check if shape can be rendered\n  const canShapeMove = checkCanShapeMove(gutter, {\n    type: current.type,\n    orientation: current.orientation,\n    position: incrementedPosition\n  })\n\n  if (!canShapeMove) {\n    return\n  }\n\n  dispatch(currentActions.move(incrementedPosition))\n\n  // render new grid\n  const gridState: GridState = {\n    rows: !canShapeMove ? grid.rows : renderNewGrid(gutter, current),\n    gutterRows: !canShapeMove ? grid.rows : gutter\n  }\n  dispatch(update(gridState))\n}\n\nexport const rotate = (increment: number) => (dispatch: AppDispatch, getState: () => RootState): void | PayloadAction => {\n  const { grid, current, next } = getState()\n\n  const gutter = grid.gutterRows\n\n  // check if shape exists?\n  if (current == null) {\n    return useNext(dispatch, next)\n  }\n\n  // move left/right\n  const currentPosition = current.position || {x: 3, y: 0} // x = (10 - 4) / 2\n\n  // check if shape can be rendered\n  const canShapeMove = checkCanShapeMove(gutter, {\n    type: current.type,\n    orientation: (current.orientation + increment) % 4,\n    position: currentPosition\n  })\n\n  if (!canShapeMove) {\n    return\n  }\n\n  dispatch(currentActions.rotate())\n\n  // render new grid\n  const gridState: GridState = {\n    rows: !canShapeMove ? grid.rows : renderNewGrid(gutter, current),\n    gutterRows: !canShapeMove ? grid.rows : gutter\n  }\n  dispatch(update(gridState))\n}\n\nexport const useNext = (dispatch: AppDispatch, next: ShapeState): void | PayloadAction => {\n  dispatch(currentActions.update(next))\n  return dispatch(nextActions.update())\n}\n\nexport const swapHold = () => (dispatch: AppDispatch, getState: () => RootState): void | PayloadAction => {\n  const { current, hold, next } = getState()\n\n  if (hold != null) {\n    dispatch(currentActions.update(hold))\n  } else {\n    dispatch(currentActions.update(next))\n    dispatch(nextActions.update())\n  }\n\n  if (current != null) {\n    dispatch(holdActions.update(current))\n  }\n}\n\nconst removeCompleteRows = (grid: BlockProps[][]) => {\n  const newGrid = grid.filter((row) =>\n  // row is not complete\n    row.findIndex((block) => block.color === BlockColor.Empty) !== -1\n  )\n\n  const completedRowsCount = TOTAL_ROWS - newGrid.length\n\n  for (let i = 0; i < completedRowsCount; i++) {\n    newGrid.unshift(new Array<BlockProps>(TOTAL_COLUMNS)\n      .fill({\n        isGhosted: false,\n        color: BlockColor.Empty\n      }))\n  }\n\n  return {\n    rowsRemovedCount: completedRowsCount,\n    newGrid: newGrid\n  }\n}\n\nconst computeShapeCoordinates = (shape: ShapeState) => {\n  const shapeData = availableShapes[shape.type]\n  const bitmap = shapeData.bitmap[shape.orientation]\n  const position = shape.position || {x: 3, y: 0} // x = (10 - 4) / 2\n  const coordinates: Coordinate[] = []\n\n  bitmap.forEach((row, yIx) => {\n    row.forEach((bit, xIx) => {\n      if (bit === 1) {\n        coordinates.push({\n          x: position.x + xIx,\n          y: position.y + yIx\n        })\n      }\n    })\n  })\n\n  return coordinates\n}\n\nconst checkCanShapeMove = (gutter: BlockProps[][], shape: ShapeState) => {\n  const shapeCoordinates = computeShapeCoordinates(shape)\n\n  for (const coordinate of shapeCoordinates) {\n    // check if in bounds\n    if (coordinate.x >= TOTAL_COLUMNS || coordinate.x < 0) return false\n    if (coordinate.y >= TOTAL_ROWS || coordinate.y < 0) return false\n\n    // check if block exists\n    const existingBlock = gutter[coordinate.y][coordinate.x]\n\n    if (existingBlock.color !== BlockColor.Empty) {\n      return false\n    }\n  }\n\n  return true\n}\n\nconst renderNewGrid = (gutter: BlockProps[][], shape: ShapeState) => {\n  // copy existing gutter\n  const newGrid: BlockProps[][] = []\n\n  gutter.forEach((row) => {\n    const newGridRow: BlockProps[] = []\n    row.forEach((block) => {\n      newGridRow.push(block)\n    })\n    newGrid.push(newGridRow)\n  })\n\n  const shapeCoordinates = computeShapeCoordinates(shape)\n\n  shapeCoordinates.forEach((coordinate) => {\n    newGrid[coordinate.y][coordinate.x] = {\n      isGhosted: false,\n      color: availableShapes[shape.type].color\n    }\n  })\n\n  return newGrid\n}\n","import {ReactElement} from 'react'\nimport {useDispatch, useSelector} from 'react-redux'\n\nimport ShapeWindow from '../../components/shape-window/shape-window'\nimport {handleOnTouchHoldContainer} from '../../controllers/input-controller/touch-controller'\nimport {RootState} from '../../state/store'\n\nexport const NextShapeWindow = (): ReactElement => {\n  const next = useSelector((state: RootState) => state.next)\n\n  return (\n    <ShapeWindow title=\"Next\" shape={next}/>\n  )\n}\n\nexport const HoldShapeWindow = (): ReactElement => {\n  const hold = useSelector((state: RootState) => state.hold)\n  const dispatch = useDispatch()\n\n  return (\n    <ShapeWindow\n      title=\"Hold\"\n      shape={hold}\n      onTouchStart={() => dispatch(handleOnTouchHoldContainer())}\n    />\n  )\n}\n","import {AppDispatch} from '../../state/store'\nimport {swapHold} from '../game-controller/game-controller'\n\nexport const handleOnTouchHoldContainer = () => (dispatch: AppDispatch): void => {\n  dispatch(swapHold())\n}\n","import {ReactElement} from 'react'\n\nimport Block, {BlockProps} from '../block/block'\n\nimport './grid.scss'\n\ninterface GridProps {\n  rows: BlockProps[][]\n}\n\nconst Grid = ({rows}: GridProps): ReactElement => {\n  const gridContents = rows.map((row, rowIx) => {\n    const renderedRow = row.map((block, columnIx) => {\n      return (\n        <Block\n          key={`block-${rowIx}-${columnIx}`}\n          isGhosted={block.isGhosted}\n          color={block.color}\n        />\n      )\n    })\n\n    return (\n      <div className=\"grid__row\" key={`grid-row-${rowIx}`}>\n        {renderedRow}\n      </div>\n    )\n  })\n\n  return (\n    <div className=\"grid\">\n      {gridContents}\n    </div>\n  )\n}\n\nexport default Grid\n","import {useSelector} from 'react-redux'\n\nimport Grid from '../../components/grid/grid'\nimport {RootState} from '../../state/store'\nimport {ReactElement} from 'react'\n\nconst GridContainer = (): ReactElement => {\n  const grid = useSelector((state: RootState) => state.grid)\n\n  return (\n    <Grid rows={grid.rows}/>\n  )\n}\n\nexport default GridContainer\n","import {ReactElement} from 'react'\nimport {useSelector} from 'react-redux'\n\nimport {RootState} from '../../state/store'\n\nimport './stats-view.scss'\n\ninterface StatProps {\n  label: string,\n  value: number\n}\n\nconst Stat = ({ label, value }: StatProps): ReactElement => {\n  return (\n    <div className='stat'>\n      <label>{label}: </label>\n      <span>{value}</span>\n    </div>\n  )\n}\n\nconst StatsView = (): ReactElement => {\n  const game = useSelector((state: RootState) => state.game)\n\n  return (\n    <div className='stats-view-container'>\n      <Stat label='Level' value={game.level} />\n      <Stat label='Score' value={game.score} />\n      <Stat label='Lines' value={game.lines} />\n    </div>\n  )\n}\n\nexport default StatsView\n","import React, {ReactElement, useEffect} from 'react'\nimport {useDispatch, useSelector} from 'react-redux'\n\nimport {HoldShapeWindow, NextShapeWindow} from '../shape-window/shape-window'\nimport GridContainer from '../grid-container/grid-container'\nimport {tick} from '../../controllers/game-controller/game-controller'\nimport {createdInterval} from '../../state/game/game-slice'\nimport {RootState} from '../../state/store'\nimport StatsView from '../stats-view/stats-view'\n\nimport './game-view.scss'\n\ninterface GameViewProps {\n  isPaused: boolean,\n  tickInterval: number\n}\n\nconst GameView = ({ isPaused, tickInterval }: GameViewProps): ReactElement => {\n  const currentInterval = useSelector((state: RootState) => state.game.interval)\n\n  const dispatch = useDispatch()\n\n  useEffect(() => {\n    if (currentInterval == null) {\n      const interval = setInterval(() => {\n        dispatch(tick())\n      }, tickInterval)\n\n      dispatch(createdInterval(interval))\n    }\n    // eslint-disable-next-line\n\t}, [dispatch, tickInterval, isPaused])\n\n  return (\n    <React.Fragment>\n      <div className=\"game-view__grid\">\n        <GridContainer />\n      </div>\n      <div className=\"game-view__side-bar\">\n        <NextShapeWindow />\n        <HoldShapeWindow />\n        <StatsView />\n      </div>\n    </React.Fragment>\n  )\n}\n\nexport default GameView\n","import React from 'react'\n\nimport {moveToTheSide, rotate, swapHold, tick} from '../game-controller/game-controller'\nimport {pause} from '../../state/game/game-slice'\nimport {AppDispatch, RootState} from '../../state/store'\nimport {ActionCreatorWithoutPayload, PayloadAction} from '@reduxjs/toolkit'\nimport {Coordinate} from '../../state/shapes/shape-types'\n\ntype ThunkType = () => (dispatch: AppDispatch, getState: () => RootState) => (void | PayloadAction<Coordinate> | PayloadAction)\n\ninterface KeyPressHandlerType {\n [index: string]: ThunkType | ActionCreatorWithoutPayload\n}\n\nconst keyPressHandler: KeyPressHandlerType = {\n  ArrowDown: tick, // drop soft\n  ArrowLeft: () => moveToTheSide(-1), // move left\n  ArrowRight: () => moveToTheSide(1), // move right\n  ArrowUp: () => rotate(1), // rotate\n  ' ': () => () => {\n    console.log('drop: hard')\n  }, // hard drop\n  p: pause,\n  P: pause,\n  Shift: swapHold // hold\n}\n\nexport const handleKeyPress = (event: React.KeyboardEvent) => (dispatch: AppDispatch): void | PayloadAction => {\n  const handler = keyPressHandler[event.key]\n  handler && dispatch(handler())\n}\n","import {ReactElement} from 'react'\nimport {useDispatch} from 'react-redux'\n\nimport {handleKeyPress} from '../../controllers/input-controller/key-press-controller'\nimport {gameSlice} from '../../state/game/game-slice'\n\nimport './pause-view.scss'\n\nconst PauseView = (): ReactElement => {\n  const dispatch = useDispatch()\n\n  return (\n    <div className='pause-view' onKeyDown={(event) => dispatch(handleKeyPress(event))} tabIndex={-1}>\n      <p>Pause</p>\n      <button onClick={() => dispatch(gameSlice.actions.pause())}>Start</button>\n    </div>\n  )\n}\n\nexport default PauseView\n","import React, {ReactElement} from 'react'\nimport {useDispatch, useSelector} from 'react-redux'\n\nimport GameView from '../../containers/game-view/game-view'\nimport PauseView from '../../containers/pause-view/pause-view'\nimport {handleKeyPress} from '../../controllers/input-controller/key-press-controller'\nimport {RootState} from '../../state/store'\n\nimport './tetris-page.scss'\n\nconst TetrisPage = (): ReactElement => {\n  const isPaused = useSelector((state: RootState) => state.game.paused)\n  const tickInterval = useSelector((state: RootState) => state.game.tickInterval)\n\n  const dispatch = useDispatch()\n\n  return (\n    <div className=\"tetris-page\" onKeyDown={(event) => dispatch(handleKeyPress(event))} tabIndex={-1}>\n      <div className=\"tetris-page__title\">Tetris</div>\n      <div className=\"tetris-page__content\">\n        {\n          isPaused ?\n            <PauseView/>\n            : <GameView\n              isPaused={isPaused}\n              tickInterval={tickInterval}\n            />\n        }\n      </div>\n    </div>\n  )\n}\n\nexport default TetrisPage\n","import React, {ReactElement} from 'react'\nimport {HashRouter, Route, Routes} from 'react-router-dom'\n\nimport TetrisPage from './pages/tetris/tetris-page'\n\nimport './App.scss'\n\nconst App = (): ReactElement => {\n  return (\n    <div className=\"app\">\n      <HashRouter basename=\"/\">\n        <Routes>\n          <Route path=\"/\" element={<TetrisPage />} />\n        </Routes>\n      </HashRouter>\n      <footer className='app__footer'>\n       made with &hearts; by <a href='https://github.com/leahferrell/tetris-react' target='_blank' rel=\"noreferrer\">leahferrell</a>\n      </footer>\n    </div>\n  )\n}\n\nexport default App\n","import {configureStore} from '@reduxjs/toolkit'\n\nimport {gameSlice} from './game/game-slice'\nimport {gridSlice} from './grid/grid-slice'\nimport {currentSlice} from './shapes/current-slice'\nimport {holdSlice} from './shapes/hold-slice'\nimport {nextSlice} from './shapes/next-slice'\n\nexport const store = configureStore({\n  reducer: {\n    current: currentSlice.reducer,\n    game: gameSlice.reducer,\n    grid: gridSlice.reducer,\n    hold: holdSlice.reducer,\n    next: nextSlice.reducer\n  }\n})\n\nexport type RootState = ReturnType<typeof store.getState>\nexport type AppDispatch = typeof store.dispatch\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport {Provider} from 'react-redux'\n\nimport App from './App'\nimport {store} from './state/store'\n\nimport './index.scss'\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}