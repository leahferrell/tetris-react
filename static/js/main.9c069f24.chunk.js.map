{"version":3,"sources":["data/shapes.ts","components/block/block.tsx","components/shape/shape.tsx","components/shape-window/shape-window.tsx","components/grid/grid.tsx","views/stats-view/stats-view.tsx","state/shapes/shapes-slice.ts","state/grid/grid-slice.ts","data/grid.ts","state/game/game-slice.ts","data/game.ts","controller/game-controller/game-controller.ts","controller/input-controller/input-controller.ts","views/game-view/game-view.tsx","App.tsx","state/store.ts","index.tsx"],"names":["BlockColor","ShapeType","availableShapes","L","bitmap","color","Orange","O","Yellow","T","Purple","S","Green","Z","Red","J","Blue","I","Teal","totalNumShapes","Object","keys","length","Block","isGhosted","classNames","Empty","toLowerCase","filter","Boolean","join","className","Shape","type","orientation","position","renderedShape","map","row","rowIx","renderedRow","isFilled","columnIx","ShapeWindow","title","shape","Grid","gridContents","rows","block","Stat","label","value","StatsView","level","score","lines","generateNextShape","Math","floor","random","initialState","next","shapesSlice","createSlice","name","reducers","swapHold","state","current","hold","useNext","rotateShape","move","action","payload","actions","generateInitialGrid","numOfRows","numOfColumns","Array","fill","gutterRows","gridSlice","update","gameOver","paused","remainingLines","tickInterval","gameSlice","removedLines","countRemovedLines","pause","tick","dispatch","getState","grid","shapes","gutter","currentShape","checkCanShapeMove","removeCompleteRows","rowsRemovedCount","newGrid","gridState","renderNewGrid","currentPosition","x","y","incrementedPosition","moveToTheSide","movement","canShapeMove","findIndex","completedRowsCount","i","unshift","computeShapeCoordinates","coordinates","forEach","yIx","bit","xIx","push","shapeCoordinates","coordinate","newGridRow","keyPressHandler","ArrowDown","ArrowLeft","ArrowRight","ArrowUp","increment","console","log","p","P","Shift","GameView","useSelector","game","useState","initializedInterval","setInitializedInterval","useDispatch","useEffect","setInterval","onKeyDown","event","handler","key","handleKeyPress","tabIndex","App","basename","path","element","store","configureStore","reducer","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.9c069f24.chunk.js","sourcesContent":["export enum BlockColor {\n\tEmpty,\n\tRed,\n\tGreen,\n\tBlue,\n\tPurple,\n\tYellow,\n\tTeal,\n\tOrange\n}\n\nexport enum ShapeType {\n\tI,\n\tO,\n\tT,\n\tS,\n\tZ,\n\tJ,\n\tL\n}\n\nexport interface ShapeData {\n\tbitmap: number[][][],\n\tcolor: BlockColor\n}\n\nexport interface ShapesData {\n\t[index: number]: ShapeData\n}\n\nexport const availableShapes: ShapesData = {\n\t[ShapeType.L]: {\n\t\tbitmap: [\n\t\t\t[\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[1,1,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,0,0,0],\n\t\t\t\t[1,0,0,0],\n\t\t\t\t[1,1,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,1,1,0],\n\t\t\t\t[1,0,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,1,1,0],\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[0,0,1,0]\n\t\t\t]\n\t\t],\n\t\tcolor: BlockColor.Orange\n\t},\n\t[ShapeType.O]: {\n\t\tbitmap: [\n\t\t\t[\n\t\t\t\t[0,1,1,0],\n\t\t\t\t[0,1,1,0]\n\t\t\t]\n\t\t],\n\t\tcolor: BlockColor.Yellow\n\t},\n\t[ShapeType.T]: {\n\t\tbitmap: [\n\t\t\t[\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[1,1,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[0,1,1,0],\n\t\t\t\t[0,1,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,1,1,0],\n\t\t\t\t[0,1,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[1,1,0,0],\n\t\t\t\t[0,1,0,0]\n\t\t\t]\n\t\t],\n\t\tcolor: BlockColor.Purple\n\t},\n\t[ShapeType.S]: {\n\t\tbitmap: [\n\t\t\t[\n\t\t\t\t[0,1,1,0],\n\t\t\t\t[1,1,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[0,1,1,0],\n\t\t\t\t[0,0,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,1,1,0],\n\t\t\t\t[1,1,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,0,0,0],\n\t\t\t\t[1,1,0,0],\n\t\t\t\t[0,1,0,0]\n\t\t\t]\n\t\t],\n\t\tcolor: BlockColor.Green\n\t},\n\t[ShapeType.Z]: {\n\t\tbitmap: [\n\t\t\t[\n\t\t\t\t[1,1,0,0],\n\t\t\t\t[0,1,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[0,1,1,0],\n\t\t\t\t[0,1,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,1,0,0],\n\t\t\t\t[0,1,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[1,1,0,0],\n\t\t\t\t[1,0,0,0]\n\t\t\t]\n\t\t],\n\t\tcolor: BlockColor.Red\n\t},\n\t[ShapeType.J]: {\n\t\tbitmap: [\n\t\t\t[\n\t\t\t\t[1,0,0,0],\n\t\t\t\t[1,1,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,1,0,0],\n\t\t\t\t[1,0,0,0],\n\t\t\t\t[1,0,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,1,1,0],\n\t\t\t\t[0,0,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[0,1,1,0]\n\t\t\t]\n\t\t],\n\t\tcolor: BlockColor.Blue\n\t},\n\t[ShapeType.I]: {\n\t\tbitmap: [\n\t\t\t[\n\t\t\t\t[1,1,1,1],\n\t\t\t\t[0,0,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[0,0,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,1,1,1],\n\t\t\t\t[0,0,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[0,1,0,0]\n\t\t\t]\n\t\t],\n\t\tcolor: BlockColor.Teal\n\t},\n}\n\nexport const totalNumShapes = Object.keys(availableShapes).length\n","import './block.scss'\nimport {BlockColor} from '../../data/shapes'\n\nexport interface BlockProps {\n\tisGhosted: boolean,\n\tcolor: BlockColor\n}\n\nconst Block = ({ isGhosted, color }: BlockProps) => {\n\tconst classNames = [\n\t\t'block',\n\t\tBlockColor.Empty !== color && `block--${BlockColor[color].toLowerCase()}`,\n\t\tisGhosted && 'block--ghosted'\n\t].filter( Boolean ).join(' ')\n\n\treturn (\n\t\t<div className={classNames}/>\n\t)\n}\n\nexport default Block\n","import {ShapeProps} from '../../state/shapes/shapes-slice'\nimport Block from '../block/block'\nimport {availableShapes, BlockColor} from '../../data/shapes'\nimport './shape.scss'\n\nconst Shape = ({type, orientation, position}: ShapeProps) => {\n\tif (type == null) {\n\t\treturn <div/>\n\t}\n\n\tconst renderedShape = availableShapes[type].bitmap[orientation].map((row, rowIx) => {\n\t\tconst renderedRow = row.map((isFilled, columnIx) => {\n\t\t\treturn (\n\t\t\t\t<Block\n\t\t\t\t\tkey={`shape-block-${rowIx}-${columnIx}`}\n\t\t\t\t\tisGhosted={false}\n\t\t\t\t\tcolor={isFilled? availableShapes[type].color : BlockColor.Empty}\n\t\t\t\t/>\n\t\t\t)\n\t\t})\n\n\t\treturn (\n\t\t\t<div className='shape__row' key={`shape-row-${rowIx}`}>\n\t\t\t\t{renderedRow}\n\t\t\t</div>\n\t\t)\n\t})\n\n\treturn (\n\t\t<div className='shape'>{renderedShape}</div>\n\t)\n}\n\nexport default Shape\n","import './shape-window.scss'\nimport {ShapeProps} from \"../../state/shapes/shapes-slice\";\nimport Shape from \"../shape/shape\";\n\nexport interface ShapeWindowProps {\n\ttitle: string,\n\tshape?: ShapeProps\n}\n\nconst ShapeWindow = ({ title, shape }: ShapeWindowProps) => {\n\treturn (\n\t\t<div className='shape-window'>\n\t\t\t<p>{title}</p>\n\t\t\t{shape && <Shape {...shape} /> }\n\t\t</div>\n\t)\n}\n\nexport default ShapeWindow\n","import './grid.scss'\nimport Block, {BlockProps} from \"../block/block\";\n\ninterface GridProps {\n\trows: BlockProps[][]\n}\n\nconst Grid = ({ rows }: GridProps) => {\n\tconst gridContents = rows.map((row, rowIx) => {\n\t\tconst renderedRow = row.map((block, columnIx) => {\n\t\t\treturn (\n\t\t\t\t<Block\n\t\t\t\t\tkey={`block-${rowIx}-${columnIx}`}\n\t\t\t\t\tisGhosted={block.isGhosted}\n\t\t\t\t\tcolor={block.color}\n\t\t\t\t/>\n\t\t\t)\n\t\t})\n\n\t\treturn (\n\t\t\t<div className='grid__row' key={`grid-row-${rowIx}`}>\n\t\t\t\t{renderedRow}\n\t\t\t</div>\n\t\t)\n\t})\n\n\treturn (\n\t\t<div className='grid'>\n\t\t\t{gridContents}\n\t\t</div>\n\t)\n}\n\nexport default Grid\n","import './stats-view.scss'\n\nconst Stat = ({ label, value }: { label: string, value: number }) => {\n\treturn (\n\t\t<div className='stat'>\n\t\t\t<label>{label}</label>\n\t\t\t<p>{value}</p>\n\t\t</div>\n\t)\n}\n\nexport interface StatsViewProps {\n\tlevel: number,\n\tscore: number,\n\tlines: number\n}\n\nconst StatsView = ({ level, score, lines }: StatsViewProps) => {\n\treturn (\n\t\t<div className='stats-view-container'>\n\t\t\t<Stat label='Level' value={level} />\n\t\t\t<Stat label='Score' value={score} />\n\t\t\t<Stat label='Lines' value={lines} />\n\t\t</div>\n\t)\n}\n\nexport default StatsView\n","import {createSlice, PayloadAction} from '@reduxjs/toolkit'\nimport {ShapeType, totalNumShapes} from '../../data/shapes'\n\nexport interface Coordinate {\n\tx: number,\n\ty: number\n}\n\nexport interface ShapeProps {\n\ttype: ShapeType,\n\torientation: number,\n\tposition?: Coordinate\n}\n\nexport interface ShapesState {\n\tnext: ShapeProps,\n\thold?: ShapeProps,\n\tcurrent?: ShapeProps\n}\n\nexport const generateNextShape = () => {\n\tconst shapeTypeId = Math.floor(Math.random() * totalNumShapes)\n\tconst shape: ShapeProps = {\n\t\ttype: shapeTypeId,\n\t\torientation: 0\n\t}\n\n\treturn shape\n}\n\nconst initialState: ShapesState = {\n\tnext: generateNextShape()\n}\n\nexport const shapesSlice = createSlice({\n\tname: 'shapes',\n\tinitialState,\n\treducers: {\n\t\tswapHold: (state: ShapesState) => {\n\t\t\tif (state.current == null) {\n\t\t\t\treturn state\n\t\t\t}\n\n\t\t\tif (state.hold == null) {\n\t\t\t\treturn {\n\t\t\t\t\t...state,\n\t\t\t\t\thold: state.current,\n\t\t\t\t\tcurrent: state.next,\n\t\t\t\t\tnext: generateNextShape() // TODO: i need to not do this since it's non deterministic, but not sure of a cleaner approach\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\thold: state.current,\n\t\t\t\tcurrent: state.hold\n\t\t\t}\n\t\t},\n\t\tuseNext: (state: ShapesState) => {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tcurrent: state.next,\n\t\t\t\tnext: generateNextShape() // TODO: i need to not do this since it's non deterministic, but not sure of a cleaner approach\n\t\t\t}\n\t\t},\n\t\trotateShape: (state: ShapesState) => {\n\t\t\tif (state.current == null) {\n\t\t\t\treturn state\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tcurrent: {\n\t\t\t\t\t...state.current,\n\t\t\t\t\torientation: (state.current.orientation + 1) % 4\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tmove: (state: ShapesState, action: PayloadAction<Coordinate>) => {\n\t\t\tif (state.current == null) {\n\t\t\t\treturn state\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tcurrent: {\n\t\t\t\t\t...state.current,\n\t\t\t\t\tposition: action.payload\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n})\n\nexport const {swapHold, useNext, rotateShape, move} = shapesSlice.actions\n\n","import {BlockProps} from '../../components/block/block'\nimport {createSlice, PayloadAction} from '@reduxjs/toolkit'\nimport {BlockColor} from '../../data/shapes'\nimport {TOTAL_COLUMNS, TOTAL_ROWS} from '../../data/grid'\n\nexport const generateInitialGrid = (numOfRows: number, numOfColumns: number) => {\n\treturn new Array(numOfRows)\n\t\t.fill(\n\t\t\tnew Array(numOfColumns)\n\t\t\t\t.fill({\n\t\t\t\t\tisGhosted: false,\n\t\t\t\t\tcolor: BlockColor.Empty\n\t\t\t\t})\n\t\t)\n}\n\nexport interface GridState {\n\trows: BlockProps[][],\n\tgutterRows: BlockProps[][]\n}\n\nconst initialState: GridState = {\n\trows: generateInitialGrid(TOTAL_ROWS, TOTAL_COLUMNS),\n\tgutterRows: generateInitialGrid(TOTAL_ROWS, TOTAL_COLUMNS)\n}\n\nexport const gridSlice = createSlice({\n\tname: 'grid',\n\tinitialState,\n\treducers: {\n\t\tupdate: (state: GridState, action: PayloadAction<GridState>) => {\n\t\t\treturn action.payload\n\t\t}\n\t}\n})\n\nexport const { update } = gridSlice.actions\n","export const TOTAL_ROWS = 20\nexport const TOTAL_COLUMNS = 10\n","import {createSlice, PayloadAction} from '@reduxjs/toolkit'\nimport {TICK_INTERVAL} from '../../data/game'\n\nexport interface GameState {\n\tgameOver: boolean,\n\tlevel: number,\n\tlines: number,\n\tpaused: boolean,\n\tremainingLines: number,\n\tscore: number,\n\ttickInterval: number\n}\n\nconst initialState: GameState = {\n\tgameOver: false,\n\tlevel: 1,\n\tlines: 0,\n\tpaused: false,\n\tremainingLines: 10,\n\tscore: 0,\n\ttickInterval: TICK_INTERVAL\n}\n\nexport const gameSlice = createSlice({\n\tname: 'game',\n\tinitialState,\n\treducers: {\n\t\tremovedLines: (state: GameState, action: PayloadAction<number>) => {\n\t\t\tconst countRemovedLines = action.payload\n\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tlines: state.lines + countRemovedLines,\n\t\t\t\tremainingLines: state.remainingLines - countRemovedLines,\n\t\t\t\tscore: state.score + (100 * countRemovedLines)\n\t\t\t}\n\t\t},\n\t\tpause: (state: GameState) => {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tpaused: !state.paused\n\t\t\t}\n\t\t}\n\t}\n})\n\nexport const { pause, removedLines } = gameSlice.actions\n","export const TICK_INTERVAL = 1000 // 1 second\n","import {AppDispatch, RootState} from '../../state/store'\nimport {Coordinate, move, rotateShape, ShapeProps, useNext} from '../../state/shapes/shapes-slice'\nimport {BlockProps} from '../../components/block/block'\nimport {availableShapes, BlockColor} from '../../data/shapes'\nimport {GridState, update} from '../../state/grid/grid-slice'\nimport {TOTAL_COLUMNS, TOTAL_ROWS} from '../../data/grid'\nimport {removedLines} from '../../state/game/game-slice'\n\nexport const tick = () => (dispatch: AppDispatch, getState: () => RootState) => {\n\tconst { grid, shapes } = getState()\n\n\tconst gutter = grid.gutterRows\n\tconst currentShape = shapes.current\n\n\t// check if shape exists?\n\tif (currentShape == null) {\n\t\treturn dispatch(useNext())\n\t}\n\n\t// check if shape can be rendered\n\tconst canShapeMove = checkCanShapeMove(gutter, currentShape)\n\n\tif (!canShapeMove) {\n\t\tconst {rowsRemovedCount, newGrid} = removeCompleteRows(grid.rows)\n\t\tdispatch(removedLines(rowsRemovedCount))\n\n\t\tconst gridState: GridState = {\n\t\t\trows: newGrid,\n\t\t\tgutterRows: newGrid\n\t\t}\n\t\tdispatch(update(gridState))\n\t\treturn dispatch(useNext())\n\t}\n\n\t// render new grid\n\tconst gridState: GridState = {\n\t\trows: renderNewGrid(gutter, currentShape),\n\t\tgutterRows: gutter\n\t}\n\tdispatch(update(gridState))\n\n\t// move down one\n\tconst currentPosition = currentShape.position || {x: 3, y: 0} // x = (10 - 4) / 2\n\tconst incrementedPosition = { x: currentPosition.x, y: currentPosition.y + 1 }\n\treturn dispatch(move(incrementedPosition))\n}\n\nexport const moveToTheSide = (movement: number) => (dispatch: AppDispatch, getState: () => RootState) => {\n\tconst { grid, shapes } = getState()\n\n\tconst gutter = grid.gutterRows\n\tconst currentShape = shapes.current\n\n\t// check if shape exists?\n\tif (currentShape == null) {\n\t\treturn dispatch(useNext())\n\t}\n\n\t// move left/right\n\tconst currentPosition = currentShape.position || {x: 3, y: 0} // x = (10 - 4) / 2\n\tconst incrementedPosition = { x: currentPosition.x + movement, y: currentPosition.y }\n\n\t// check if shape can be rendered\n\tconst canShapeMove = checkCanShapeMove(gutter, {\n\t\ttype: currentShape.type,\n\t\torientation: currentShape.orientation,\n\t\tposition: incrementedPosition\n\t})\n\n\tif (!canShapeMove) {\n\t\treturn\n\t}\n\n\tdispatch(move(incrementedPosition))\n\n\t// render new grid\n\tconst gridState: GridState = {\n\t\trows: !canShapeMove ? grid.rows : renderNewGrid(gutter, currentShape),\n\t\tgutterRows: !canShapeMove ? grid.rows : gutter\n\t}\n\tdispatch(update(gridState))\n}\n\nexport const rotate = (increment: number) => (dispatch: AppDispatch, getState: () => RootState) => {\n\tconst { grid, shapes } = getState()\n\n\tconst gutter = grid.gutterRows\n\tconst currentShape = shapes.current\n\n\t// check if shape exists?\n\tif (currentShape == null) {\n\t\treturn dispatch(useNext())\n\t}\n\n\t// move left/right\n\tconst currentPosition = currentShape.position || {x: 3, y: 0} // x = (10 - 4) / 2\n\n\t// check if shape can be rendered\n\tconst canShapeMove = checkCanShapeMove(gutter, {\n\t\ttype: currentShape.type,\n\t\torientation: (currentShape.orientation + increment) % 4,\n\t\tposition: currentPosition\n\t})\n\n\tif (!canShapeMove) {\n\t\treturn\n\t}\n\n\tdispatch(rotateShape())\n\n\t// render new grid\n\tconst gridState: GridState = {\n\t\trows: !canShapeMove ? grid.rows : renderNewGrid(gutter, currentShape),\n\t\tgutterRows: !canShapeMove ? grid.rows : gutter\n\t}\n\tdispatch(update(gridState))\n}\n\nconst removeCompleteRows = (grid: BlockProps[][]) => {\n\tconst newGrid = grid.filter((row) =>\n\t\t// row is not complete\n\t\trow.findIndex((block) => block.color === BlockColor.Empty) !== -1\n\t)\n\n\tconst completedRowsCount = TOTAL_ROWS - newGrid.length\n\n\tfor (let i = 0; i < completedRowsCount; i++) {\n\t\tnewGrid.unshift(new Array(TOTAL_COLUMNS)\n\t\t\t.fill({\n\t\t\t\tisGhosted: false,\n\t\t\t\tcolor: BlockColor.Empty\n\t\t\t}))\n\t}\n\n\treturn {\n\t\trowsRemovedCount: completedRowsCount,\n\t\tnewGrid: newGrid\n\t}\n}\n\nconst computeShapeCoordinates = (shape: ShapeProps) => {\n\tconst shapeData = availableShapes[shape.type]\n\tconst bitmap = shapeData.bitmap[shape.orientation]\n\tconst position = shape.position || {x: 3, y: 0} // x = (10 - 4) / 2\n\tconst coordinates: Coordinate[] = []\n\n\tbitmap.forEach((row, yIx) => {\n\t\trow.forEach((bit, xIx) => {\n\t\t\tif (bit === 1) {\n\t\t\t\tcoordinates.push({\n\t\t\t\t\tx: position.x + xIx,\n\t\t\t\t\ty: position.y + yIx\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t})\n\n\treturn coordinates\n}\n\nconst checkCanShapeMove = (gutter: BlockProps[][], shape: ShapeProps) => {\n\tconst shapeCoordinates = computeShapeCoordinates(shape)\n\n\tfor (let coordinate of shapeCoordinates) {\n\t\t// check if in bounds\n\t\tif (coordinate.x >= TOTAL_COLUMNS || coordinate.x < 0) return false\n\t\tif (coordinate.y >= TOTAL_ROWS || coordinate.y < 0) return false\n\n\t\t// check if block exists\n\t\tconst existingBlock = gutter[coordinate.y][coordinate.x]\n\n\t\tif (existingBlock.color !== BlockColor.Empty) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nconst renderNewGrid = (gutter: BlockProps[][], shape: ShapeProps) => {\n\t// copy existing gutter\n\tconst newGrid: BlockProps[][] = []\n\n\tgutter.forEach((row) => {\n\t\tconst newGridRow: BlockProps[] = []\n\t\trow.forEach((block) => {\n\t\t\tnewGridRow.push(block)\n\t\t})\n\t\tnewGrid.push(newGridRow)\n\t})\n\n\tconst shapeCoordinates = computeShapeCoordinates(shape)\n\n\tshapeCoordinates.forEach((coordinate) => {\n\t\tnewGrid[coordinate.y][coordinate.x] = {\n\t\t\tisGhosted: false,\n\t\t\tcolor: availableShapes[shape.type].color\n\t\t}\n\t})\n\n\treturn newGrid\n}\n","import React from 'react'\nimport {moveToTheSide, rotate, tick} from '../game-controller/game-controller'\nimport {AppDispatch, RootState} from '../../state/store'\nimport {swapHold} from '../../state/shapes/shapes-slice'\nimport {pause} from '../../state/game/game-slice'\n\ninterface KeyPressHandlerType {\n\t[index: string]: () => any\n}\n\nconst keyPressHandler: KeyPressHandlerType = {\n\tArrowDown: tick, // drop soft\n\tArrowLeft: () => moveToTheSide(-1), // move left\n\tArrowRight: () => moveToTheSide(1), // move right\n\tArrowUp: () => rotate(1), // rotate\n\t' ': () => {\n\t\tconsole.log('drop: hard')\n\t}, // hard drop\n\tp: pause,\n\tP: pause,\n\tShift: swapHold // hold\n}\n\nexport const handleKeyPress = (event: React.KeyboardEvent) => (dispatch: AppDispatch, getState: () => RootState) => {\n\tconst handler = keyPressHandler[event.key]\n\thandler && dispatch(handler())\n}\n","import './game-view.scss'\nimport ShapeWindow from '../../components/shape-window/shape-window'\nimport Grid from '../../components/grid/grid'\nimport StatsView from '../stats-view/stats-view'\nimport {useDispatch, useSelector} from 'react-redux'\nimport {RootState} from '../../state/store'\nimport {tick} from '../../controller/game-controller/game-controller'\nimport React, {useEffect, useState} from 'react'\nimport {handleKeyPress} from '../../controller/input-controller/input-controller'\n\nconst GameView = () => {\n\tconst grid = useSelector((state: RootState) => state.grid)\n\tconst game = useSelector((state: RootState) => state.game)\n\tconst shapes = useSelector((state: RootState) => state.shapes)\n\n\tconst [initializedInterval, setInitializedInterval] = useState(false)\n\n\tconst dispatch = useDispatch()\n\n\tuseEffect(() => {\n\t\tif (!initializedInterval && dispatch != null) {\n\t\t\tsetInterval(() => {\n\t\t\t\tdispatch(tick())\n\t\t\t}, game.tickInterval)\n\t\t\tsetInitializedInterval(true)\n\t\t}\n\t}, [dispatch, game.tickInterval, initializedInterval])\n\n\treturn (\n\t\t<div className=\"game-view-container\" onKeyDown={(event) => dispatch(handleKeyPress(event))} tabIndex={-1}>\n\t\t\t<div className=\"game-view-container__title\">Tetris</div>\n\t\t\t<div className=\"game-view-container__content\">\n\t\t\t\t<div className=\"game-view-container__content__available-pieces\">\n\t\t\t\t\t<ShapeWindow title=\"Hold\" shape={shapes.hold}/>\n\t\t\t\t\t<ShapeWindow title=\"Next\" shape={shapes.next}/>\n\t\t\t\t</div>\n\t\t\t\t<div className=\"game-view-container__content__grid\">\n\t\t\t\t\t<Grid rows={grid.rows}/>\n\t\t\t\t</div>\n\t\t\t\t<div className=\"game-view-container__content__stats\">\n\t\t\t\t\t<StatsView level={game.level} lines={game.lines} score={game.score}/>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n\nexport default GameView\n","import React from 'react'\nimport './App.css'\nimport GameView from './views/game-view/game-view'\nimport {useSelector} from 'react-redux'\nimport {RootState} from './state/store'\nimport PauseMenu from './views/pause-menu/pause-menu'\nimport {HashRouter, Route, Routes} from 'react-router-dom'\n\nfunction App() {\n\tconst isPaused = useSelector((state: RootState) => state.game.paused)\n\treturn (\n\t\t<div className=\"app\">\n\t\t\t<HashRouter basename=\"/\">\n\t\t\t\t<Routes>\n\t\t\t\t\t<Route path=\"/\" element={<GameView />} />\n\t\t\t\t</Routes>\n\t\t\t</HashRouter>\n\t\t</div>\n\t)\n}\n\nexport default App\n","import {configureStore} from '@reduxjs/toolkit'\nimport {gridSlice} from './grid/grid-slice'\nimport {shapesSlice} from './shapes/shapes-slice'\nimport {gameSlice} from './game/game-slice'\n\nexport const store = configureStore({\n\treducer: {\n\t\tgrid: gridSlice.reducer,\n\t\tshapes: shapesSlice.reducer,\n\t\tgame: gameSlice.reducer\n\t}\n})\n\nexport type RootState = ReturnType<typeof store.getState>\nexport type AppDispatch = typeof store.dispatch\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport {Provider} from 'react-redux'\nimport {store} from './state/store'\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}