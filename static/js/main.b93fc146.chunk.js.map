{"version":3,"sources":["data/shapes.ts","components/block/block.tsx","components/shape/shape.tsx","components/shape-window/shape-window.tsx","state/game/game-slice.ts","data/game.ts","state/grid/grid-generator.ts","state/grid/grid-slice.ts","data/grid.ts","state/shapes/current-slice.ts","state/shapes/hold-slice.ts","state/shapes/shape-generator.ts","state/shapes/next-slice.ts","controllers/game-controller/game-controller.ts","containers/shape-window/shape-window.tsx","controllers/input-controller/touch-controller.ts","components/grid/grid.tsx","containers/grid-container/grid-container.tsx","containers/stats-view/stats-view.tsx","containers/game-view/game-view.tsx","controllers/input-controller/key-press-controller.ts","containers/pause-view/pause-view.tsx","containers/game-over-view/game-over-view.tsx","containers/start-view/start-view.tsx","pages/tetris/tetris-page.tsx","App.tsx","state/store.ts","index.tsx"],"names":["BlockColor","ShapeType","availableShapes","L","bitmap","color","Orange","O","Yellow","T","Purple","S","Green","Z","Red","J","Blue","I","Teal","totalNumShapes","Object","keys","length","Block","isGhosted","classNames","Empty","toLowerCase","filter","Boolean","join","className","trimBitmap","trimmedBitmap","removeFirst","removeLast","forEach","row","trimmedBitmapRow","block","index","push","Shape","type","orientation","renderedShape","map","rowIx","renderedRow","isFilled","columnIx","ShapeWindow","title","shape","onTouchStart","initialState","gameOver","hasStarted","level","lines","paused","remainingLines","score","tickInterval","gameSlice","createSlice","name","reducers","removedLines","state","action","countRemovedLines","payload","pause","interval","clearInterval","undefined","createdInterval","start","gameActions","actions","generateInitialGrid","numOfRows","numOfColumns","Array","fill","generateEmptyRow","rows","gutterRows","gridSlice","update","clear","gridActions","currentSlice","move","position","rotate","currentActions","holdSlice","holdActions","generateNextShape","Math","floor","random","nextSlice","nextActions","newGame","dispatch","tick","getState","grid","current","next","gutter","useNext","checkCanShapeMove","removeCompleteRows","rowsRemovedCount","newGrid","isGameOver","gridState","renderNewGrid","currentPosition","x","y","incrementedPosition","moveToTheSide","movement","canShapeMove","swapHold","hold","findIndex","completedRowsCount","i","unshift","computeShapeCoordinates","coordinates","yIx","bit","xIx","shapeCoordinates","coordinate","newGridRow","NextShapeWindow","useSelector","HoldShapeWindow","useDispatch","Grid","gridContents","GridContainer","Stat","label","value","StatsView","game","GameView","isPaused","currentInterval","useEffect","setInterval","Fragment","keyPressHandler","ArrowDown","ArrowLeft","ArrowRight","ArrowUp","increment","console","log","p","P","Shift","handleKeyPress","event","handler","key","PauseView","onKeyDown","tabIndex","onClick","GameOverView","StartView","getContent","TetrisPage","App","basename","path","element","href","target","rel","store","configureStore","reducer","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.b93fc146.chunk.js","sourcesContent":["export enum BlockColor {\n  Empty,\n  Red,\n  Green,\n  Blue,\n  Purple,\n  Yellow,\n  Teal,\n  Orange\n}\n\nexport enum ShapeType {\n  I,\n  O,\n  T,\n  S,\n  Z,\n  J,\n  L\n}\n\nexport interface ShapeData {\n  bitmap: number[][][],\n  color: BlockColor\n}\n\nexport interface ShapesData {\n  [index: number]: ShapeData\n}\n\nexport const availableShapes: ShapesData = {\n  [ShapeType.L]: {\n    bitmap: [\n      [\n        [0,0,1,0],\n        [1,1,1,0]\n      ],\n      [\n        [1,0,0,0],\n        [1,0,0,0],\n        [1,1,0,0]\n      ],\n      [\n        [1,1,1,0],\n        [1,0,0,0]\n      ],\n      [\n        [0,1,1,0],\n        [0,0,1,0],\n        [0,0,1,0]\n      ]\n    ],\n    color: BlockColor.Orange\n  },\n  [ShapeType.O]: {\n    bitmap: [\n      [\n        [0,1,1,0],\n        [0,1,1,0]\n      ]\n    ],\n    color: BlockColor.Yellow\n  },\n  [ShapeType.T]: {\n    bitmap: [\n      [\n        [0,1,0,0],\n        [1,1,1,0]\n      ],\n      [\n        [0,1,0,0],\n        [0,1,1,0],\n        [0,1,0,0]\n      ],\n      [\n        [1,1,1,0],\n        [0,1,0,0]\n      ],\n      [\n        [0,1,0,0],\n        [1,1,0,0],\n        [0,1,0,0]\n      ]\n    ],\n    color: BlockColor.Purple\n  },\n  [ShapeType.S]: {\n    bitmap: [\n      [\n        [0,1,1,0],\n        [1,1,0,0]\n      ],\n      [\n        [0,1,0,0],\n        [0,1,1,0],\n        [0,0,1,0]\n      ],\n      [\n        [0,1,1,0],\n        [1,1,0,0]\n      ],\n      [\n        [1,0,0,0],\n        [1,1,0,0],\n        [0,1,0,0]\n      ]\n    ],\n    color: BlockColor.Green\n  },\n  [ShapeType.Z]: {\n    bitmap: [\n      [\n        [1,1,0,0],\n        [0,1,1,0]\n      ],\n      [\n        [0,0,1,0],\n        [0,1,1,0],\n        [0,1,0,0]\n      ],\n      [\n        [1,1,0,0],\n        [0,1,1,0]\n      ],\n      [\n        [0,1,0,0],\n        [1,1,0,0],\n        [1,0,0,0]\n      ]\n    ],\n    color: BlockColor.Red\n  },\n  [ShapeType.J]: {\n    bitmap: [\n      [\n        [1,0,0,0],\n        [1,1,1,0]\n      ],\n      [\n        [1,1,0,0],\n        [1,0,0,0],\n        [1,0,0,0]\n      ],\n      [\n        [1,1,1,0],\n        [0,0,1,0]\n      ],\n      [\n        [0,0,1,0],\n        [0,0,1,0],\n        [0,1,1,0]\n      ]\n    ],\n    color: BlockColor.Blue\n  },\n  [ShapeType.I]: {\n    bitmap: [\n      [\n        [1,1,1,1],\n        [0,0,0,0]\n      ],\n      [\n        [0,0,1,0],\n        [0,0,1,0],\n        [0,0,1,0],\n        [0,0,1,0]\n      ],\n      [\n        [1,1,1,1],\n        [0,0,0,0]\n      ],\n      [\n        [0,1,0,0],\n        [0,1,0,0],\n        [0,1,0,0],\n        [0,1,0,0]\n      ]\n    ],\n    color: BlockColor.Teal\n  },\n}\n\nexport const totalNumShapes = Object.keys(availableShapes).length\n","import {ReactElement} from 'react'\n\nimport {BlockColor} from '../../data/shapes'\n\nimport './block.scss'\n\nexport interface BlockProps {\n  isGhosted: boolean,\n  color: BlockColor\n}\n\nconst Block = ({ isGhosted, color }: BlockProps): ReactElement => {\n  const classNames = [\n    'block',\n    BlockColor.Empty !== color && `block--${BlockColor[color].toLowerCase()}`,\n    isGhosted && 'block--ghosted'\n  ].filter( Boolean ).join(' ')\n\n  return (\n    <div className={classNames}/>\n  )\n}\n\nexport default Block\n","import {ReactElement} from 'react'\n\nimport {availableShapes, BlockColor, ShapeType} from '../../data/shapes'\nimport Block from '../block/block'\n\nimport './shape.scss'\n\nexport interface ShapeProps {\n  type: ShapeType,\n  orientation: number\n}\n\nconst Shape = ({type, orientation}: ShapeProps): ReactElement => {\n  if (type == null) {\n    return <div/>\n  }\n\n  const bitmap = trimBitmap(availableShapes[type].bitmap[orientation])\n\n  const renderedShape = bitmap.map((row, rowIx) => {\n    const renderedRow = row.map((isFilled, columnIx) => {\n      return (\n        <Block\n          key={`shape-block-${rowIx}-${columnIx}`}\n          isGhosted={false}\n          color={isFilled? availableShapes[type].color : BlockColor.Empty}\n        />\n      )\n    })\n\n    return (\n      <div className='shape__row' key={`shape-row-${rowIx}`}>\n        {renderedRow}\n      </div>\n    )\n  })\n\n  return (\n    <div className='shape'>{renderedShape}</div>\n  )\n}\n\nconst trimBitmap = (bitmap: number[][]) => {\n  const trimmedBitmap: number[][] = []\n  const removeFirst = bitmap[0][0] === 0 && bitmap[1][0] === 0\n  const removeLast = bitmap[0][bitmap[0].length-1] === 0 && bitmap[1][bitmap[0].length-1] === 0\n\n  bitmap.forEach((row) => {\n    const trimmedBitmapRow: number[] = []\n    row.forEach((block, index) => {\n      if ((index !== 0 || !removeFirst) && (index !== row.length-1 || !removeLast)) {\n        trimmedBitmapRow.push(block)\n      }\n    })\n    trimmedBitmap.push(trimmedBitmapRow)\n  })\n\n\n\n  return trimmedBitmap\n}\n\nexport default Shape\n","import {ReactElement, TouchEventHandler} from 'react'\n\nimport {NullableShapeState} from '../../state/shapes/shape-types'\nimport Shape from '../shape/shape'\n\nimport './shape-window.scss'\n\nexport interface ShapeWindowProps {\n  onTouchStart?: TouchEventHandler | undefined,\n  title: string,\n  shape: NullableShapeState\n}\n\nconst ShapeWindow = ({title, shape, onTouchStart}: ShapeWindowProps): ReactElement => {\n  return (\n    <div onTouchStart={onTouchStart} className=\"shape-window\">\n      <p>{title}</p>\n      {shape && <Shape {...shape} />}\n    </div>\n  )\n}\n\nexport default ShapeWindow\n","import {createSlice, PayloadAction} from '@reduxjs/toolkit'\nimport {TICK_INTERVAL} from '../../data/game'\n\nexport interface GameState {\n  gameOver: boolean,\n  hasStarted: boolean,\n  interval?: NodeJS.Timeout,\n  level: number,\n  lines: number,\n  paused: boolean,\n  remainingLines: number,\n  score: number,\n  tickInterval: number\n}\n\nconst initialState: GameState = {\n  gameOver: false,\n  hasStarted: false,\n  level: 1,\n  lines: 0,\n  paused: true,\n  remainingLines: 10,\n  score: 0,\n  tickInterval: TICK_INTERVAL\n}\n\nexport const gameSlice = createSlice({\n  name: 'game',\n  initialState,\n  reducers: {\n    removedLines: (state: GameState, action: PayloadAction<number>) => {\n      const countRemovedLines = action.payload\n\n      return {\n        ...state,\n        lines: state.lines + countRemovedLines,\n        remainingLines: state.remainingLines - countRemovedLines,\n        score: state.score + (100 * countRemovedLines)\n      }\n    },\n    pause: (state: GameState) => {\n      if (state.interval != null) {\n        clearInterval(state.interval) // TODO: figure out where to put this since this is a side effect\n      }\n\n      return {\n        ...state,\n        interval: undefined,\n        paused: !state.paused\n      }\n    },\n    createdInterval: (state: GameState, action: PayloadAction<NodeJS.Timeout>) => {\n      if (state.interval != null) {\n        clearInterval(state.interval) // TODO: figure out where to put this since this is a side effect\n      }\n\n      return {\n        ...state,\n        interval: action.payload\n      }\n    },\n    start: () => {\n      return {\n        ...initialState,\n        hasStarted: true,\n        paused: false\n      }\n    },\n    gameOver: (state: GameState) => {\n      if (state.interval != null) {\n        clearInterval(state.interval) // TODO: figure out where to put this since this is a side effect\n      }\n\n      return {\n        ...state,\n        paused: true,\n        gameOver: true\n      }\n    }\n  }\n})\n\nexport const gameActions = gameSlice.actions\n","export const TICK_INTERVAL = 1000 // 1 second\n","import {BlockColor} from '../../data/shapes'\nimport {BlockProps} from '../../components/block/block'\n\nexport const generateInitialGrid = (numOfRows: number, numOfColumns: number): BlockProps[][] => {\n  return new Array<BlockProps[]>(numOfRows).fill(generateEmptyRow(numOfColumns))\n}\n\nexport const generateEmptyRow = (numOfColumns: number): BlockProps[] => {\n  return new Array<BlockProps>(numOfColumns).fill({\n    isGhosted: false,\n    color: BlockColor.Empty\n  })\n}\n","import {createSlice, PayloadAction} from '@reduxjs/toolkit'\n\nimport {BlockProps} from '../../components/block/block'\nimport {TOTAL_COLUMNS, TOTAL_ROWS} from '../../data/grid'\nimport {generateInitialGrid} from './grid-generator'\n\nexport interface GridState {\n  rows: BlockProps[][],\n  gutterRows: BlockProps[][]\n}\n\nconst initialState: GridState = {\n  rows: generateInitialGrid(TOTAL_ROWS, TOTAL_COLUMNS),\n  gutterRows: generateInitialGrid(TOTAL_ROWS, TOTAL_COLUMNS)\n}\n\nexport const gridSlice = createSlice({\n  name: 'grid',\n  initialState,\n  reducers: {\n    update: (state: GridState, action: PayloadAction<GridState>) => {\n      return action.payload\n    },\n    clear: () => {\n      return initialState\n    }\n  }\n})\n\nexport const gridActions = gridSlice.actions\n","export const TOTAL_ROWS = 20\nexport const TOTAL_COLUMNS = 10\n","import {createSlice, PayloadAction} from '@reduxjs/toolkit'\n\nimport {Coordinate, NullableShapeState, ShapeState} from './shape-types'\n\nconst initialState: NullableShapeState = null as NullableShapeState\n\nexport const currentSlice = createSlice({\n  name: 'current',\n  initialState,\n  reducers: {\n    move: (state: NullableShapeState, action: PayloadAction<Coordinate>) => {\n      if (state == null) {\n        return state\n      }\n\n      return {\n        ...state,\n        position: action.payload\n      }\n    },\n    rotate: (state: NullableShapeState) => {\n      if (state == null) {\n        return state\n      }\n\n      return {\n        ...state,\n        orientation: (state.orientation + 1) % 4\n      }\n    },\n    update: (state: NullableShapeState, action: PayloadAction<ShapeState>) => {\n      if (action.payload != null) {\n        return action.payload\n      } else {\n        return state\n      }\n    },\n    clear: () => {\n      return null\n    }\n  }\n})\n\nexport const currentActions = currentSlice.actions\n","import {createSlice, PayloadAction} from '@reduxjs/toolkit'\n\nimport {NullableShapeState, ShapeState} from './shape-types'\n\nconst initialState: NullableShapeState = null as NullableShapeState\n\nexport const holdSlice = createSlice({\n  name: 'hold',\n  initialState,\n  reducers: {\n    update: (state: NullableShapeState, action: PayloadAction<ShapeState>) => {\n      if (action.payload != null) {\n        return action.payload\n      } else {\n        return state\n      }\n    },\n    clear: () => {\n      return null\n    }\n  }\n})\n\nexport const holdActions = holdSlice.actions\n","import {totalNumShapes} from '../../data/shapes'\nimport {ShapeState} from './shape-types'\n\nexport const generateNextShape = (): ShapeState => {\n  const shapeTypeId = Math.floor(Math.random() * totalNumShapes)\n  return {\n    type: shapeTypeId,\n    orientation: 0\n  }\n}\n","import {createSlice} from '@reduxjs/toolkit'\n\nimport {ShapeState} from './shape-types'\nimport {generateNextShape} from './shape-generator'\n\nconst initialState: ShapeState = generateNextShape()\n\nexport const nextSlice = createSlice({\n  name: 'next',\n  initialState,\n  reducers: {\n    update: () => {\n      return generateNextShape() // TODO: fix this\n    },\n    clear: () => {\n      return generateNextShape()\n    }\n  }\n})\n\nexport const nextActions = nextSlice.actions\n","import {PayloadAction} from '@reduxjs/toolkit'\n\nimport {BlockProps} from '../../components/block/block'\nimport {TOTAL_COLUMNS, TOTAL_ROWS} from '../../data/grid'\nimport {availableShapes, BlockColor} from '../../data/shapes'\nimport {gameActions} from '../../state/game/game-slice'\nimport {gridActions, GridState} from '../../state/grid/grid-slice'\nimport {currentActions} from '../../state/shapes/current-slice'\nimport {holdActions} from '../../state/shapes/hold-slice'\nimport {nextActions} from '../../state/shapes/next-slice'\nimport {Coordinate, ShapeState} from '../../state/shapes/shape-types'\nimport {AppDispatch, RootState} from '../../state/store'\n\nexport const newGame = () => (dispatch: AppDispatch): void => {\n  dispatch(currentActions.clear())\n  dispatch(nextActions.clear())\n  dispatch(holdActions.clear())\n  dispatch(gridActions.clear())\n  dispatch(gameActions.start())\n}\n\nexport const tick = () => (dispatch: AppDispatch, getState: () => RootState): void | PayloadAction<Coordinate> | PayloadAction => {\n  const { grid, current, next } = getState()\n\n  const gutter = grid.gutterRows\n\n  // check if shape exists?\n  if (current == null) {\n    return useNext(dispatch, next)\n  }\n\n  // check if shape can be rendered\n  const canShapeMove = checkCanShapeMove(gutter, current)\n\n  if (!canShapeMove) {\n    const {rowsRemovedCount, newGrid} = removeCompleteRows(grid.rows)\n\n    if (rowsRemovedCount > 0) {\n      dispatch(gameActions.removedLines(rowsRemovedCount))\n    }\n\n    if (isGameOver()) {\n      return dispatch(gameActions.gameOver())\n    }\n\n    const gridState: GridState = {\n      rows: newGrid,\n      gutterRows: newGrid\n    }\n    dispatch(gridActions.update(gridState))\n    return useNext(dispatch, next)\n  }\n\n  // render new grid\n  const gridState: GridState = {\n    rows: renderNewGrid(gutter, current),\n    gutterRows: gutter\n  }\n  dispatch(gridActions.update(gridState))\n\n  // move down one\n  const currentPosition = current.position || {x: 3, y: 0} // x = (10 - 4) / 2\n  const incrementedPosition = { x: currentPosition.x, y: currentPosition.y + 1 }\n  return dispatch(currentActions.move(incrementedPosition))\n}\n\nexport const moveToTheSide = (movement: number) => (dispatch: AppDispatch, getState: () => RootState): void | PayloadAction => {\n  const { grid, current, next } = getState()\n\n  const gutter = grid.gutterRows\n\n  // check if shape exists?\n  if (current == null) {\n    return useNext(dispatch, next)\n  }\n\n  // move left/right\n  const currentPosition = current.position || {x: 3, y: 0} // x = (10 - 4) / 2\n  const incrementedPosition = { x: currentPosition.x + movement, y: currentPosition.y }\n\n  // check if shape can be rendered\n  const canShapeMove = checkCanShapeMove(gutter, {\n    type: current.type,\n    orientation: current.orientation,\n    position: incrementedPosition\n  })\n\n  if (!canShapeMove) {\n    return\n  }\n\n  dispatch(currentActions.move(incrementedPosition))\n\n  // render new grid\n  const gridState: GridState = {\n    rows: !canShapeMove ? grid.rows : renderNewGrid(gutter, current),\n    gutterRows: !canShapeMove ? grid.rows : gutter\n  }\n  dispatch(gridActions.update(gridState))\n}\n\nexport const rotate = (increment: number) => (dispatch: AppDispatch, getState: () => RootState): void | PayloadAction => {\n  const { grid, current, next } = getState()\n\n  const gutter = grid.gutterRows\n\n  // check if shape exists?\n  if (current == null) {\n    return useNext(dispatch, next)\n  }\n\n  // move left/right\n  const currentPosition = current.position || {x: 3, y: 0} // x = (10 - 4) / 2\n\n  // check if shape can be rendered\n  const canShapeMove = checkCanShapeMove(gutter, {\n    type: current.type,\n    orientation: (current.orientation + increment) % 4,\n    position: currentPosition\n  })\n\n  if (!canShapeMove) {\n    return\n  }\n\n  dispatch(currentActions.rotate())\n\n  // render new grid\n  const gridState: GridState = {\n    rows: !canShapeMove ? grid.rows : renderNewGrid(gutter, current),\n    gutterRows: !canShapeMove ? grid.rows : gutter\n  }\n  dispatch(gridActions.update(gridState))\n}\n\nexport const useNext = (dispatch: AppDispatch, next: ShapeState): void | PayloadAction => {\n  dispatch(currentActions.update(next))\n  return dispatch(nextActions.update())\n}\n\nexport const swapHold = () => (dispatch: AppDispatch, getState: () => RootState): void | PayloadAction => {\n  const { current, hold, next } = getState()\n\n  if (hold != null) {\n    dispatch(currentActions.update(hold))\n  } else {\n    dispatch(currentActions.update(next))\n    dispatch(nextActions.update())\n  }\n\n  if (current != null) {\n    dispatch(holdActions.update(current))\n  }\n}\n\nconst isGameOver = (): boolean => {\n  return false\n}\n\nconst removeCompleteRows = (grid: BlockProps[][]) => {\n  const newGrid = grid.filter((row) =>\n  // row is not complete\n    row.findIndex((block) => block.color === BlockColor.Empty) !== -1\n  )\n\n  const completedRowsCount = TOTAL_ROWS - newGrid.length\n\n  for (let i = 0; i < completedRowsCount; i++) {\n    newGrid.unshift(new Array<BlockProps>(TOTAL_COLUMNS)\n      .fill({\n        isGhosted: false,\n        color: BlockColor.Empty\n      }))\n  }\n\n  return {\n    rowsRemovedCount: completedRowsCount,\n    newGrid: newGrid\n  }\n}\n\nconst computeShapeCoordinates = (shape: ShapeState) => {\n  const shapeData = availableShapes[shape.type]\n  const bitmap = shapeData.bitmap[shape.orientation]\n  const position = shape.position || {x: 3, y: 0} // x = (10 - 4) / 2\n  const coordinates: Coordinate[] = []\n\n  bitmap.forEach((row, yIx) => {\n    row.forEach((bit, xIx) => {\n      if (bit === 1) {\n        coordinates.push({\n          x: position.x + xIx,\n          y: position.y + yIx\n        })\n      }\n    })\n  })\n\n  return coordinates\n}\n\nconst checkCanShapeMove = (gutter: BlockProps[][], shape: ShapeState) => {\n  const shapeCoordinates = computeShapeCoordinates(shape)\n\n  for (const coordinate of shapeCoordinates) {\n    // check if in bounds\n    if (coordinate.x >= TOTAL_COLUMNS || coordinate.x < 0) return false\n    if (coordinate.y >= TOTAL_ROWS || coordinate.y < 0) return false\n\n    // check if block exists\n    const existingBlock = gutter[coordinate.y][coordinate.x]\n\n    if (existingBlock.color !== BlockColor.Empty) {\n      return false\n    }\n  }\n\n  return true\n}\n\nconst renderNewGrid = (gutter: BlockProps[][], shape: ShapeState) => {\n  // copy existing gutter\n  const newGrid: BlockProps[][] = []\n\n  gutter.forEach((row) => {\n    const newGridRow: BlockProps[] = []\n    row.forEach((block) => {\n      newGridRow.push(block)\n    })\n    newGrid.push(newGridRow)\n  })\n\n  const shapeCoordinates = computeShapeCoordinates(shape)\n\n  shapeCoordinates.forEach((coordinate) => {\n    newGrid[coordinate.y][coordinate.x] = {\n      isGhosted: false,\n      color: availableShapes[shape.type].color\n    }\n  })\n\n  return newGrid\n}\n","import {ReactElement} from 'react'\nimport {useDispatch, useSelector} from 'react-redux'\n\nimport ShapeWindow from '../../components/shape-window/shape-window'\nimport {handleOnTouchHoldContainer} from '../../controllers/input-controller/touch-controller'\nimport {RootState} from '../../state/store'\n\nexport const NextShapeWindow = (): ReactElement => {\n  const next = useSelector((state: RootState) => state.next)\n\n  return (\n    <ShapeWindow title=\"Next\" shape={next}/>\n  )\n}\n\nexport const HoldShapeWindow = (): ReactElement => {\n  const hold = useSelector((state: RootState) => state.hold)\n  const dispatch = useDispatch()\n\n  return (\n    <ShapeWindow\n      title=\"Hold\"\n      shape={hold}\n      onTouchStart={() => dispatch(handleOnTouchHoldContainer())}\n    />\n  )\n}\n","import {AppDispatch} from '../../state/store'\nimport {swapHold} from '../game-controller/game-controller'\n\nexport const handleOnTouchHoldContainer = () => (dispatch: AppDispatch): void => {\n  dispatch(swapHold())\n}\n","import {ReactElement} from 'react'\n\nimport Block, {BlockProps} from '../block/block'\n\nimport './grid.scss'\n\ninterface GridProps {\n  rows: BlockProps[][]\n}\n\nconst Grid = ({rows}: GridProps): ReactElement => {\n  const gridContents = rows.map((row, rowIx) => {\n    const renderedRow = row.map((block, columnIx) => {\n      return (\n        <Block\n          key={`block-${rowIx}-${columnIx}`}\n          isGhosted={block.isGhosted}\n          color={block.color}\n        />\n      )\n    })\n\n    return (\n      <div className=\"grid__row\" key={`grid-row-${rowIx}`}>\n        {renderedRow}\n      </div>\n    )\n  })\n\n  return (\n    <div className=\"grid\">\n      {gridContents}\n    </div>\n  )\n}\n\nexport default Grid\n","import {useSelector} from 'react-redux'\n\nimport Grid from '../../components/grid/grid'\nimport {RootState} from '../../state/store'\nimport {ReactElement} from 'react'\n\nconst GridContainer = (): ReactElement => {\n  const grid = useSelector((state: RootState) => state.grid)\n\n  return (\n    <Grid rows={grid.rows}/>\n  )\n}\n\nexport default GridContainer\n","import {ReactElement} from 'react'\nimport {useSelector} from 'react-redux'\n\nimport {RootState} from '../../state/store'\n\nimport './stats-view.scss'\n\ninterface StatProps {\n  label: string,\n  value: number\n}\n\nconst Stat = ({ label, value }: StatProps): ReactElement => {\n  return (\n    <div className='stat'>\n      <label>{label}: </label>\n      <span>{value}</span>\n    </div>\n  )\n}\n\nconst StatsView = (): ReactElement => {\n  const game = useSelector((state: RootState) => state.game)\n\n  return (\n    <div className='stats-view-container'>\n      <Stat label='Level' value={game.level} />\n      <Stat label='Score' value={game.score} />\n      <Stat label='Lines' value={game.lines} />\n    </div>\n  )\n}\n\nexport default StatsView\n","import React, {ReactElement, useEffect} from 'react'\nimport {useDispatch, useSelector} from 'react-redux'\n\nimport {HoldShapeWindow, NextShapeWindow} from '../shape-window/shape-window'\nimport GridContainer from '../grid-container/grid-container'\nimport {tick} from '../../controllers/game-controller/game-controller'\nimport {gameActions} from '../../state/game/game-slice'\nimport {RootState} from '../../state/store'\nimport StatsView from '../stats-view/stats-view'\n\nimport './game-view.scss'\n\ninterface GameViewProps {\n  isPaused: boolean,\n  tickInterval: number\n}\n\nconst GameView = ({ isPaused, tickInterval }: GameViewProps): ReactElement => {\n  const currentInterval = useSelector((state: RootState) => state.game.interval)\n\n  const dispatch = useDispatch()\n\n  useEffect(() => {\n    if (currentInterval == null) {\n      const interval = setInterval(() => {\n        dispatch(tick())\n      }, tickInterval)\n\n      dispatch(gameActions.createdInterval(interval))\n    }\n    // eslint-disable-next-line\n\t}, [dispatch, tickInterval, isPaused])\n\n  return (\n    <React.Fragment>\n      <div className=\"game-view__grid\">\n        <GridContainer />\n      </div>\n      <div className=\"game-view__side-bar\">\n        <NextShapeWindow />\n        <HoldShapeWindow />\n        <StatsView />\n      </div>\n    </React.Fragment>\n  )\n}\n\nexport default GameView\n","import React from 'react'\n\nimport {moveToTheSide, rotate, swapHold, tick} from '../game-controller/game-controller'\nimport {gameActions} from '../../state/game/game-slice'\nimport {AppDispatch, RootState} from '../../state/store'\nimport {ActionCreatorWithoutPayload, PayloadAction} from '@reduxjs/toolkit'\nimport {Coordinate} from '../../state/shapes/shape-types'\n\ntype ThunkType = () => (dispatch: AppDispatch, getState: () => RootState) => (void | PayloadAction<Coordinate> | PayloadAction)\n\ninterface KeyPressHandlerType {\n [index: string]: ThunkType | ActionCreatorWithoutPayload\n}\n\nconst keyPressHandler: KeyPressHandlerType = {\n  ArrowDown: tick, // drop soft\n  ArrowLeft: () => moveToTheSide(-1), // move left\n  ArrowRight: () => moveToTheSide(1), // move right\n  ArrowUp: () => rotate(1), // rotate\n  ' ': () => () => {\n    console.log('drop: hard')\n  }, // hard drop\n  p: gameActions.pause,\n  P: gameActions.pause,\n  Shift: swapHold // hold\n}\n\nexport const handleKeyPress = (event: React.KeyboardEvent) => (dispatch: AppDispatch): void | PayloadAction => {\n  const handler = keyPressHandler[event.key]\n  handler && dispatch(handler())\n}\n","import {ReactElement} from 'react'\nimport {useDispatch} from 'react-redux'\n\nimport {newGame} from '../../controllers/game-controller/game-controller'\nimport {handleKeyPress} from '../../controllers/input-controller/key-press-controller'\nimport {gameSlice} from '../../state/game/game-slice'\n\nimport './pause-view.scss'\n\nconst PauseView = (): ReactElement => {\n  const dispatch = useDispatch()\n\n  return (\n    <div className='pause-view' onKeyDown={(event) => dispatch(handleKeyPress(event))} tabIndex={-1}>\n      <p>Pause</p>\n      <button onClick={() => dispatch(gameSlice.actions.pause())}>Resume</button>\n      <button onClick={() => dispatch(newGame())}>Restart</button>\n    </div>\n  )\n}\n\nexport default PauseView\n","import {ReactElement} from 'react'\nimport {useDispatch} from 'react-redux'\n\nimport {newGame} from '../../controllers/game-controller/game-controller'\n\nimport './game-over-view.scss'\n\nconst GameOverView = (): ReactElement => {\n  const dispatch = useDispatch()\n\n  return (\n    <div className='game-over-view'>\n      <p>Game Over</p>\n      <button onClick={() => dispatch(newGame())}>Start a new game</button>\n    </div>\n  )\n}\n\nexport default GameOverView\n","import {ReactElement} from 'react'\nimport {useDispatch} from 'react-redux'\n\nimport {newGame} from '../../controllers/game-controller/game-controller'\n\nimport './start-view.scss'\n\nconst StartView = (): ReactElement => {\n  const dispatch = useDispatch()\n\n  return (\n    <div className='start-view'>\n      <p>Start a game!</p>\n      <button onClick={() => dispatch(newGame())}>Start</button>\n    </div>\n  )\n}\n\nexport default StartView\n","import React, {ReactElement} from 'react'\nimport {useDispatch, useSelector} from 'react-redux'\n\nimport GameView from '../../containers/game-view/game-view'\nimport PauseView from '../../containers/pause-view/pause-view'\nimport {handleKeyPress} from '../../controllers/input-controller/key-press-controller'\nimport {RootState} from '../../state/store'\n\nimport './tetris-page.scss'\nimport GameOverView from '../../containers/game-over-view/game-over-view'\nimport StartView from '../../containers/start-view/start-view'\n\nconst TetrisPage = (): ReactElement => {\n  const gameOver = useSelector((state: RootState) => state.game.gameOver)\n  const hasStarted = useSelector((state: RootState) => state.game.hasStarted)\n  const isPaused = useSelector((state: RootState) => state.game.paused)\n  const tickInterval = useSelector((state: RootState) => state.game.tickInterval)\n\n  const dispatch = useDispatch()\n\n  return (\n    <div className=\"tetris-page\" onKeyDown={(event) => dispatch(handleKeyPress(event))} tabIndex={-1}>\n      <div className=\"tetris-page__title\">Tetris</div>\n      <div className=\"tetris-page__content\">\n        {getContent(gameOver, hasStarted, isPaused, tickInterval)}\n      </div>\n    </div>\n  )\n}\n\nconst getContent = (\n  gameOver: boolean,\n  hasStarted: boolean,\n  isPaused: boolean,\n  tickInterval: number\n): ReactElement => {\n  if (gameOver) {\n    return <GameOverView/>\n  }\n\n  if (!hasStarted) {\n    return <StartView/>\n  }\n\n  if (isPaused) {\n    return <PauseView/>\n  }\n\n  return <GameView\n    isPaused={isPaused}\n    tickInterval={tickInterval}\n  />\n}\n\nexport default TetrisPage\n","import React, {ReactElement} from 'react'\nimport {HashRouter, Route, Routes} from 'react-router-dom'\n\nimport TetrisPage from './pages/tetris/tetris-page'\n\nimport './App.scss'\n\nconst App = (): ReactElement => {\n  return (\n    <div className=\"app\">\n      <HashRouter basename=\"/\">\n        <Routes>\n          <Route path=\"/\" element={<TetrisPage />} />\n        </Routes>\n      </HashRouter>\n      <footer className='app__footer'>\n       made with &hearts; by <a href='https://github.com/leahferrell/tetris-react' target='_blank' rel=\"noreferrer\">leahferrell</a>\n      </footer>\n    </div>\n  )\n}\n\nexport default App\n","import {configureStore} from '@reduxjs/toolkit'\n\nimport {gameSlice} from './game/game-slice'\nimport {gridSlice} from './grid/grid-slice'\nimport {currentSlice} from './shapes/current-slice'\nimport {holdSlice} from './shapes/hold-slice'\nimport {nextSlice} from './shapes/next-slice'\n\nexport const store = configureStore({\n  reducer: {\n    current: currentSlice.reducer,\n    game: gameSlice.reducer,\n    grid: gridSlice.reducer,\n    hold: holdSlice.reducer,\n    next: nextSlice.reducer\n  }\n})\n\nexport type RootState = ReturnType<typeof store.getState>\nexport type AppDispatch = typeof store.dispatch\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport {Provider} from 'react-redux'\n\nimport App from './App'\nimport {store} from './state/store'\n\nimport './index.scss'\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}