{"version":3,"sources":["data/shapes.ts","components/block/block.tsx","components/grid/grid.tsx","components/shape/shape.tsx","components/shape-window/shape-window.tsx","state/shapes/shapes-slice.ts","state/grid/grid-slice.ts","data/grid.ts","state/game/game-slice.ts","data/game.ts","controller/game-controller/game-controller.ts","controller/input-controller/input-controller.ts","views/stats-view/stats-view.tsx","views/game-view/game-view.tsx","App.tsx","state/store.ts","index.tsx"],"names":["BlockColor","ShapeType","availableShapes","L","bitmap","color","Orange","O","Yellow","T","Purple","S","Green","Z","Red","J","Blue","I","Teal","totalNumShapes","Object","keys","length","Block","isGhosted","classNames","Empty","toLowerCase","filter","Boolean","join","className","Grid","gridContents","rows","map","row","rowIx","renderedRow","block","columnIx","trimBitmap","trimmedBitmap","removeFirst","removeLast","forEach","trimmedBitmapRow","index","push","Shape","type","orientation","position","renderedShape","isFilled","ShapeWindow","title","shape","generateNextShape","Math","floor","random","initialState","next","shapesSlice","createSlice","name","reducers","swapHold","state","current","hold","useNext","rotateShape","move","action","payload","actions","generateInitialGrid","numOfRows","numOfColumns","Array","fill","gutterRows","gridSlice","update","gameOver","level","lines","paused","remainingLines","score","tickInterval","gameSlice","removedLines","countRemovedLines","pause","tick","dispatch","getState","grid","shapes","gutter","currentShape","checkCanShapeMove","removeCompleteRows","rowsRemovedCount","newGrid","gridState","renderNewGrid","currentPosition","x","y","incrementedPosition","moveToTheSide","movement","canShapeMove","findIndex","completedRowsCount","i","unshift","computeShapeCoordinates","coordinates","yIx","bit","xIx","shapeCoordinates","coordinate","newGridRow","keyPressHandler","ArrowDown","ArrowLeft","ArrowRight","ArrowUp","increment","console","log","p","P","Shift","Stat","label","value","StatsView","GameView","useSelector","game","useState","initializedInterval","setInitializedInterval","useDispatch","useEffect","setInterval","onKeyDown","event","handler","key","handleKeyPress","tabIndex","App","basename","path","element","href","target","store","configureStore","reducer","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.f29d5261.chunk.js","sourcesContent":["export enum BlockColor {\n\tEmpty,\n\tRed,\n\tGreen,\n\tBlue,\n\tPurple,\n\tYellow,\n\tTeal,\n\tOrange\n}\n\nexport enum ShapeType {\n\tI,\n\tO,\n\tT,\n\tS,\n\tZ,\n\tJ,\n\tL\n}\n\nexport interface ShapeData {\n\tbitmap: number[][][],\n\tcolor: BlockColor\n}\n\nexport interface ShapesData {\n\t[index: number]: ShapeData\n}\n\nexport const availableShapes: ShapesData = {\n\t[ShapeType.L]: {\n\t\tbitmap: [\n\t\t\t[\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[1,1,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,0,0,0],\n\t\t\t\t[1,0,0,0],\n\t\t\t\t[1,1,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,1,1,0],\n\t\t\t\t[1,0,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,1,1,0],\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[0,0,1,0]\n\t\t\t]\n\t\t],\n\t\tcolor: BlockColor.Orange\n\t},\n\t[ShapeType.O]: {\n\t\tbitmap: [\n\t\t\t[\n\t\t\t\t[0,1,1,0],\n\t\t\t\t[0,1,1,0]\n\t\t\t]\n\t\t],\n\t\tcolor: BlockColor.Yellow\n\t},\n\t[ShapeType.T]: {\n\t\tbitmap: [\n\t\t\t[\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[1,1,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[0,1,1,0],\n\t\t\t\t[0,1,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,1,1,0],\n\t\t\t\t[0,1,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[1,1,0,0],\n\t\t\t\t[0,1,0,0]\n\t\t\t]\n\t\t],\n\t\tcolor: BlockColor.Purple\n\t},\n\t[ShapeType.S]: {\n\t\tbitmap: [\n\t\t\t[\n\t\t\t\t[0,1,1,0],\n\t\t\t\t[1,1,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[0,1,1,0],\n\t\t\t\t[0,0,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,1,1,0],\n\t\t\t\t[1,1,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,0,0,0],\n\t\t\t\t[1,1,0,0],\n\t\t\t\t[0,1,0,0]\n\t\t\t]\n\t\t],\n\t\tcolor: BlockColor.Green\n\t},\n\t[ShapeType.Z]: {\n\t\tbitmap: [\n\t\t\t[\n\t\t\t\t[1,1,0,0],\n\t\t\t\t[0,1,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[0,1,1,0],\n\t\t\t\t[0,1,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,1,0,0],\n\t\t\t\t[0,1,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[1,1,0,0],\n\t\t\t\t[1,0,0,0]\n\t\t\t]\n\t\t],\n\t\tcolor: BlockColor.Red\n\t},\n\t[ShapeType.J]: {\n\t\tbitmap: [\n\t\t\t[\n\t\t\t\t[1,0,0,0],\n\t\t\t\t[1,1,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,1,0,0],\n\t\t\t\t[1,0,0,0],\n\t\t\t\t[1,0,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,1,1,0],\n\t\t\t\t[0,0,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[0,1,1,0]\n\t\t\t]\n\t\t],\n\t\tcolor: BlockColor.Blue\n\t},\n\t[ShapeType.I]: {\n\t\tbitmap: [\n\t\t\t[\n\t\t\t\t[1,1,1,1],\n\t\t\t\t[0,0,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[0,0,1,0],\n\t\t\t\t[0,0,1,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[1,1,1,1],\n\t\t\t\t[0,0,0,0]\n\t\t\t],\n\t\t\t[\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[0,1,0,0],\n\t\t\t\t[0,1,0,0]\n\t\t\t]\n\t\t],\n\t\tcolor: BlockColor.Teal\n\t},\n}\n\nexport const totalNumShapes = Object.keys(availableShapes).length\n","import './block.scss'\nimport {BlockColor} from '../../data/shapes'\n\nexport interface BlockProps {\n\tisGhosted: boolean,\n\tcolor: BlockColor\n}\n\nconst Block = ({ isGhosted, color }: BlockProps) => {\n\tconst classNames = [\n\t\t'block',\n\t\tBlockColor.Empty !== color && `block--${BlockColor[color].toLowerCase()}`,\n\t\tisGhosted && 'block--ghosted'\n\t].filter( Boolean ).join(' ')\n\n\treturn (\n\t\t<div className={classNames}/>\n\t)\n}\n\nexport default Block\n","import './grid.scss'\nimport Block, {BlockProps} from \"../block/block\";\n\ninterface GridProps {\n\trows: BlockProps[][]\n}\n\nconst Grid = ({ rows }: GridProps) => {\n\tconst gridContents = rows.map((row, rowIx) => {\n\t\tconst renderedRow = row.map((block, columnIx) => {\n\t\t\treturn (\n\t\t\t\t<Block\n\t\t\t\t\tkey={`block-${rowIx}-${columnIx}`}\n\t\t\t\t\tisGhosted={block.isGhosted}\n\t\t\t\t\tcolor={block.color}\n\t\t\t\t/>\n\t\t\t)\n\t\t})\n\n\t\treturn (\n\t\t\t<div className='grid__row' key={`grid-row-${rowIx}`}>\n\t\t\t\t{renderedRow}\n\t\t\t</div>\n\t\t)\n\t})\n\n\treturn (\n\t\t<div className='grid'>\n\t\t\t{gridContents}\n\t\t</div>\n\t)\n}\n\nexport default Grid\n","import {ShapeProps} from '../../state/shapes/shapes-slice'\nimport Block from '../block/block'\nimport {availableShapes, BlockColor} from '../../data/shapes'\nimport './shape.scss'\n\nconst Shape = ({type, orientation, position}: ShapeProps) => {\n\tif (type == null) {\n\t\treturn <div/>\n\t}\n\n\tconst bitmap = trimBitmap(availableShapes[type].bitmap[orientation])\n\n\tconst renderedShape = bitmap.map((row, rowIx) => {\n\t\tconst renderedRow = row.map((isFilled, columnIx) => {\n\t\t\treturn (\n\t\t\t\t<Block\n\t\t\t\t\tkey={`shape-block-${rowIx}-${columnIx}`}\n\t\t\t\t\tisGhosted={false}\n\t\t\t\t\tcolor={isFilled? availableShapes[type].color : BlockColor.Empty}\n\t\t\t\t/>\n\t\t\t)\n\t\t})\n\n\t\treturn (\n\t\t\t<div className='shape__row' key={`shape-row-${rowIx}`}>\n\t\t\t\t{renderedRow}\n\t\t\t</div>\n\t\t)\n\t})\n\n\treturn (\n\t\t<div className='shape'>{renderedShape}</div>\n\t)\n}\n\nconst trimBitmap = (bitmap: number[][]) => {\n\tconst trimmedBitmap: number[][] = []\n\tconst removeFirst = bitmap[0][0] === 0 && bitmap[1][0] === 0\n\tconst removeLast = bitmap[0][bitmap[0].length-1] === 0 && bitmap[1][bitmap[0].length-1] === 0\n\n\tbitmap.forEach((row) => {\n\t\tconst trimmedBitmapRow: number[] = []\n\t\trow.forEach((block, index) => {\n\t\t\tif ((index !== 0 || !removeFirst) && (index !== row.length-1 || !removeLast)) {\n\t\t\t\ttrimmedBitmapRow.push(block)\n\t\t\t}\n\t\t})\n\t\ttrimmedBitmap.push(trimmedBitmapRow)\n\t})\n\n\n\n\treturn trimmedBitmap\n}\n\nexport default Shape\n","import './shape-window.scss'\nimport {ShapeProps} from \"../../state/shapes/shapes-slice\";\nimport Shape from \"../shape/shape\";\n\nexport interface ShapeWindowProps {\n\ttitle: string,\n\tshape?: ShapeProps\n}\n\nconst ShapeWindow = ({ title, shape }: ShapeWindowProps) => {\n\treturn (\n\t\t<div className='shape-window'>\n\t\t\t<p>{title}</p>\n\t\t\t{shape && <Shape {...shape} /> }\n\t\t</div>\n\t)\n}\n\nexport default ShapeWindow\n","import {createSlice, PayloadAction} from '@reduxjs/toolkit'\nimport {ShapeType, totalNumShapes} from '../../data/shapes'\n\nexport interface Coordinate {\n\tx: number,\n\ty: number\n}\n\nexport interface ShapeProps {\n\ttype: ShapeType,\n\torientation: number,\n\tposition?: Coordinate\n}\n\nexport interface ShapesState {\n\tnext: ShapeProps,\n\thold?: ShapeProps,\n\tcurrent?: ShapeProps\n}\n\nexport const generateNextShape = () => {\n\tconst shapeTypeId = Math.floor(Math.random() * totalNumShapes)\n\tconst shape: ShapeProps = {\n\t\ttype: shapeTypeId,\n\t\torientation: 0\n\t}\n\n\treturn shape\n}\n\nconst initialState: ShapesState = {\n\tnext: generateNextShape()\n}\n\nexport const shapesSlice = createSlice({\n\tname: 'shapes',\n\tinitialState,\n\treducers: {\n\t\tswapHold: (state: ShapesState) => {\n\t\t\tif (state.current == null) {\n\t\t\t\treturn state\n\t\t\t}\n\n\t\t\tif (state.hold == null) {\n\t\t\t\treturn {\n\t\t\t\t\t...state,\n\t\t\t\t\thold: state.current,\n\t\t\t\t\tcurrent: state.next,\n\t\t\t\t\tnext: generateNextShape() // TODO: i need to not do this since it's non deterministic, but not sure of a cleaner approach\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\thold: state.current,\n\t\t\t\tcurrent: state.hold\n\t\t\t}\n\t\t},\n\t\tuseNext: (state: ShapesState) => {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tcurrent: state.next,\n\t\t\t\tnext: generateNextShape() // TODO: i need to not do this since it's non deterministic, but not sure of a cleaner approach\n\t\t\t}\n\t\t},\n\t\trotateShape: (state: ShapesState) => {\n\t\t\tif (state.current == null) {\n\t\t\t\treturn state\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tcurrent: {\n\t\t\t\t\t...state.current,\n\t\t\t\t\torientation: (state.current.orientation + 1) % 4\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tmove: (state: ShapesState, action: PayloadAction<Coordinate>) => {\n\t\t\tif (state.current == null) {\n\t\t\t\treturn state\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tcurrent: {\n\t\t\t\t\t...state.current,\n\t\t\t\t\tposition: action.payload\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n})\n\nexport const {swapHold, useNext, rotateShape, move} = shapesSlice.actions\n\n","import {BlockProps} from '../../components/block/block'\nimport {createSlice, PayloadAction} from '@reduxjs/toolkit'\nimport {BlockColor} from '../../data/shapes'\nimport {TOTAL_COLUMNS, TOTAL_ROWS} from '../../data/grid'\n\nexport const generateInitialGrid = (numOfRows: number, numOfColumns: number) => {\n\treturn new Array(numOfRows)\n\t\t.fill(\n\t\t\tnew Array(numOfColumns)\n\t\t\t\t.fill({\n\t\t\t\t\tisGhosted: false,\n\t\t\t\t\tcolor: BlockColor.Empty\n\t\t\t\t})\n\t\t)\n}\n\nexport interface GridState {\n\trows: BlockProps[][],\n\tgutterRows: BlockProps[][]\n}\n\nconst initialState: GridState = {\n\trows: generateInitialGrid(TOTAL_ROWS, TOTAL_COLUMNS),\n\tgutterRows: generateInitialGrid(TOTAL_ROWS, TOTAL_COLUMNS)\n}\n\nexport const gridSlice = createSlice({\n\tname: 'grid',\n\tinitialState,\n\treducers: {\n\t\tupdate: (state: GridState, action: PayloadAction<GridState>) => {\n\t\t\treturn action.payload\n\t\t}\n\t}\n})\n\nexport const { update } = gridSlice.actions\n","export const TOTAL_ROWS = 20\nexport const TOTAL_COLUMNS = 10\n","import {createSlice, PayloadAction} from '@reduxjs/toolkit'\nimport {TICK_INTERVAL} from '../../data/game'\n\nexport interface GameState {\n\tgameOver: boolean,\n\tlevel: number,\n\tlines: number,\n\tpaused: boolean,\n\tremainingLines: number,\n\tscore: number,\n\ttickInterval: number\n}\n\nconst initialState: GameState = {\n\tgameOver: false,\n\tlevel: 1,\n\tlines: 0,\n\tpaused: false,\n\tremainingLines: 10,\n\tscore: 0,\n\ttickInterval: TICK_INTERVAL\n}\n\nexport const gameSlice = createSlice({\n\tname: 'game',\n\tinitialState,\n\treducers: {\n\t\tremovedLines: (state: GameState, action: PayloadAction<number>) => {\n\t\t\tconst countRemovedLines = action.payload\n\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tlines: state.lines + countRemovedLines,\n\t\t\t\tremainingLines: state.remainingLines - countRemovedLines,\n\t\t\t\tscore: state.score + (100 * countRemovedLines)\n\t\t\t}\n\t\t},\n\t\tpause: (state: GameState) => {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tpaused: !state.paused\n\t\t\t}\n\t\t}\n\t}\n})\n\nexport const { pause, removedLines } = gameSlice.actions\n","export const TICK_INTERVAL = 1000 // 1 second\n","import {AppDispatch, RootState} from '../../state/store'\nimport {Coordinate, move, rotateShape, ShapeProps, useNext} from '../../state/shapes/shapes-slice'\nimport {BlockProps} from '../../components/block/block'\nimport {availableShapes, BlockColor} from '../../data/shapes'\nimport {GridState, update} from '../../state/grid/grid-slice'\nimport {TOTAL_COLUMNS, TOTAL_ROWS} from '../../data/grid'\nimport {removedLines} from '../../state/game/game-slice'\n\nexport const tick = () => (dispatch: AppDispatch, getState: () => RootState) => {\n\tconst { grid, shapes } = getState()\n\n\tconst gutter = grid.gutterRows\n\tconst currentShape = shapes.current\n\n\t// check if shape exists?\n\tif (currentShape == null) {\n\t\treturn dispatch(useNext())\n\t}\n\n\t// check if shape can be rendered\n\tconst canShapeMove = checkCanShapeMove(gutter, currentShape)\n\n\tif (!canShapeMove) {\n\t\tconst {rowsRemovedCount, newGrid} = removeCompleteRows(grid.rows)\n\t\tdispatch(removedLines(rowsRemovedCount))\n\n\t\tconst gridState: GridState = {\n\t\t\trows: newGrid,\n\t\t\tgutterRows: newGrid\n\t\t}\n\t\tdispatch(update(gridState))\n\t\treturn dispatch(useNext())\n\t}\n\n\t// render new grid\n\tconst gridState: GridState = {\n\t\trows: renderNewGrid(gutter, currentShape),\n\t\tgutterRows: gutter\n\t}\n\tdispatch(update(gridState))\n\n\t// move down one\n\tconst currentPosition = currentShape.position || {x: 3, y: 0} // x = (10 - 4) / 2\n\tconst incrementedPosition = { x: currentPosition.x, y: currentPosition.y + 1 }\n\treturn dispatch(move(incrementedPosition))\n}\n\nexport const moveToTheSide = (movement: number) => (dispatch: AppDispatch, getState: () => RootState) => {\n\tconst { grid, shapes } = getState()\n\n\tconst gutter = grid.gutterRows\n\tconst currentShape = shapes.current\n\n\t// check if shape exists?\n\tif (currentShape == null) {\n\t\treturn dispatch(useNext())\n\t}\n\n\t// move left/right\n\tconst currentPosition = currentShape.position || {x: 3, y: 0} // x = (10 - 4) / 2\n\tconst incrementedPosition = { x: currentPosition.x + movement, y: currentPosition.y }\n\n\t// check if shape can be rendered\n\tconst canShapeMove = checkCanShapeMove(gutter, {\n\t\ttype: currentShape.type,\n\t\torientation: currentShape.orientation,\n\t\tposition: incrementedPosition\n\t})\n\n\tif (!canShapeMove) {\n\t\treturn\n\t}\n\n\tdispatch(move(incrementedPosition))\n\n\t// render new grid\n\tconst gridState: GridState = {\n\t\trows: !canShapeMove ? grid.rows : renderNewGrid(gutter, currentShape),\n\t\tgutterRows: !canShapeMove ? grid.rows : gutter\n\t}\n\tdispatch(update(gridState))\n}\n\nexport const rotate = (increment: number) => (dispatch: AppDispatch, getState: () => RootState) => {\n\tconst { grid, shapes } = getState()\n\n\tconst gutter = grid.gutterRows\n\tconst currentShape = shapes.current\n\n\t// check if shape exists?\n\tif (currentShape == null) {\n\t\treturn dispatch(useNext())\n\t}\n\n\t// move left/right\n\tconst currentPosition = currentShape.position || {x: 3, y: 0} // x = (10 - 4) / 2\n\n\t// check if shape can be rendered\n\tconst canShapeMove = checkCanShapeMove(gutter, {\n\t\ttype: currentShape.type,\n\t\torientation: (currentShape.orientation + increment) % 4,\n\t\tposition: currentPosition\n\t})\n\n\tif (!canShapeMove) {\n\t\treturn\n\t}\n\n\tdispatch(rotateShape())\n\n\t// render new grid\n\tconst gridState: GridState = {\n\t\trows: !canShapeMove ? grid.rows : renderNewGrid(gutter, currentShape),\n\t\tgutterRows: !canShapeMove ? grid.rows : gutter\n\t}\n\tdispatch(update(gridState))\n}\n\nconst removeCompleteRows = (grid: BlockProps[][]) => {\n\tconst newGrid = grid.filter((row) =>\n\t\t// row is not complete\n\t\trow.findIndex((block) => block.color === BlockColor.Empty) !== -1\n\t)\n\n\tconst completedRowsCount = TOTAL_ROWS - newGrid.length\n\n\tfor (let i = 0; i < completedRowsCount; i++) {\n\t\tnewGrid.unshift(new Array(TOTAL_COLUMNS)\n\t\t\t.fill({\n\t\t\t\tisGhosted: false,\n\t\t\t\tcolor: BlockColor.Empty\n\t\t\t}))\n\t}\n\n\treturn {\n\t\trowsRemovedCount: completedRowsCount,\n\t\tnewGrid: newGrid\n\t}\n}\n\nconst computeShapeCoordinates = (shape: ShapeProps) => {\n\tconst shapeData = availableShapes[shape.type]\n\tconst bitmap = shapeData.bitmap[shape.orientation]\n\tconst position = shape.position || {x: 3, y: 0} // x = (10 - 4) / 2\n\tconst coordinates: Coordinate[] = []\n\n\tbitmap.forEach((row, yIx) => {\n\t\trow.forEach((bit, xIx) => {\n\t\t\tif (bit === 1) {\n\t\t\t\tcoordinates.push({\n\t\t\t\t\tx: position.x + xIx,\n\t\t\t\t\ty: position.y + yIx\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t})\n\n\treturn coordinates\n}\n\nconst checkCanShapeMove = (gutter: BlockProps[][], shape: ShapeProps) => {\n\tconst shapeCoordinates = computeShapeCoordinates(shape)\n\n\tfor (let coordinate of shapeCoordinates) {\n\t\t// check if in bounds\n\t\tif (coordinate.x >= TOTAL_COLUMNS || coordinate.x < 0) return false\n\t\tif (coordinate.y >= TOTAL_ROWS || coordinate.y < 0) return false\n\n\t\t// check if block exists\n\t\tconst existingBlock = gutter[coordinate.y][coordinate.x]\n\n\t\tif (existingBlock.color !== BlockColor.Empty) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nconst renderNewGrid = (gutter: BlockProps[][], shape: ShapeProps) => {\n\t// copy existing gutter\n\tconst newGrid: BlockProps[][] = []\n\n\tgutter.forEach((row) => {\n\t\tconst newGridRow: BlockProps[] = []\n\t\trow.forEach((block) => {\n\t\t\tnewGridRow.push(block)\n\t\t})\n\t\tnewGrid.push(newGridRow)\n\t})\n\n\tconst shapeCoordinates = computeShapeCoordinates(shape)\n\n\tshapeCoordinates.forEach((coordinate) => {\n\t\tnewGrid[coordinate.y][coordinate.x] = {\n\t\t\tisGhosted: false,\n\t\t\tcolor: availableShapes[shape.type].color\n\t\t}\n\t})\n\n\treturn newGrid\n}\n","import React from 'react'\nimport {moveToTheSide, rotate, tick} from '../game-controller/game-controller'\nimport {AppDispatch, RootState} from '../../state/store'\nimport {swapHold} from '../../state/shapes/shapes-slice'\nimport {pause} from '../../state/game/game-slice'\n\ninterface KeyPressHandlerType {\n\t[index: string]: () => any\n}\n\nconst keyPressHandler: KeyPressHandlerType = {\n\tArrowDown: tick, // drop soft\n\tArrowLeft: () => moveToTheSide(-1), // move left\n\tArrowRight: () => moveToTheSide(1), // move right\n\tArrowUp: () => rotate(1), // rotate\n\t' ': () => {\n\t\tconsole.log('drop: hard')\n\t}, // hard drop\n\tp: pause,\n\tP: pause,\n\tShift: swapHold // hold\n}\n\nexport const handleKeyPress = (event: React.KeyboardEvent) => (dispatch: AppDispatch, getState: () => RootState) => {\n\tconst handler = keyPressHandler[event.key]\n\thandler && dispatch(handler())\n}\n","import './stats-view.scss'\n\nconst Stat = ({ label, value }: { label: string, value: number }) => {\n\treturn (\n\t\t<div className='stat'>\n\t\t\t<label>{label}: </label>\n\t\t\t<span>{value}</span>\n\t\t</div>\n\t)\n}\n\nexport interface StatsViewProps {\n\tlevel: number,\n\tscore: number,\n\tlines: number\n}\n\nconst StatsView = ({ level, score, lines }: StatsViewProps) => {\n\treturn (\n\t\t<div className='stats-view-container'>\n\t\t\t<Stat label='Level' value={level} />\n\t\t\t<Stat label='Score' value={score} />\n\t\t\t<Stat label='Lines' value={lines} />\n\t\t</div>\n\t)\n}\n\nexport default StatsView\n","import React, {useEffect, useState} from 'react'\nimport {useDispatch, useSelector} from 'react-redux'\n\nimport Grid from '../../components/grid/grid'\nimport ShapeWindow from '../../components/shape-window/shape-window'\nimport {tick} from '../../controller/game-controller/game-controller'\nimport {handleKeyPress} from '../../controller/input-controller/input-controller'\nimport {RootState} from '../../state/store'\nimport StatsView from '../stats-view/stats-view'\n\nimport './game-view.scss'\n\nconst GameView = () => {\n\tconst grid = useSelector((state: RootState) => state.grid)\n\tconst game = useSelector((state: RootState) => state.game)\n\tconst shapes = useSelector((state: RootState) => state.shapes)\n\n\tconst [initializedInterval, setInitializedInterval] = useState(false)\n\n\tconst dispatch = useDispatch()\n\n\tuseEffect(() => {\n\t\tif (!initializedInterval && dispatch != null) {\n\t\t\tsetInterval(() => {\n\t\t\t\tdispatch(tick())\n\t\t\t}, game.tickInterval)\n\t\t\tsetInitializedInterval(true)\n\t\t}\n\t}, [dispatch, game.tickInterval, initializedInterval])\n\n\treturn (\n\t\t<div className=\"game-view-container\" onKeyDown={(event) => dispatch(handleKeyPress(event))} tabIndex={-1}>\n\t\t\t<div className=\"game-view-container__title\">Tetris</div>\n\t\t\t<div className=\"game-view-container__content\">\n\t\t\t\t<div className=\"game-view-container__content__grid\">\n\t\t\t\t\t<Grid rows={grid.rows}/>\n\t\t\t\t</div>\n\t\t\t\t<div className=\"game-view-container__content__side-bar\">\n\t\t\t\t\t<ShapeWindow title=\"Next\" shape={shapes.next}/>\n\t\t\t\t\t<ShapeWindow title=\"Hold\" shape={shapes.hold}/>\n\t\t\t\t\t<StatsView level={game.level} lines={game.lines} score={game.score}/>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n\nexport default GameView\n","import React from 'react'\nimport './App.scss'\nimport GameView from './views/game-view/game-view'\nimport {useSelector} from 'react-redux'\nimport {RootState} from './state/store'\nimport PauseMenu from './views/pause-menu/pause-menu'\nimport {HashRouter, Route, Routes} from 'react-router-dom'\n\nfunction App() {\n\tconst isPaused = useSelector((state: RootState) => state.game.paused)\n\treturn (\n\t\t<div className=\"app\">\n\t\t\t<HashRouter basename=\"/\">\n\t\t\t\t<Routes>\n\t\t\t\t\t<Route path=\"/\" element={<GameView />} />\n\t\t\t\t</Routes>\n\t\t\t</HashRouter>\n\t\t\t<footer className='app__footer'>\n\t\t\t\tmade with &hearts; by <a href='https://github.com/leahferrell/tetris-react' target='_blank'>leahferrell</a>\n\t\t\t</footer>\n\t\t</div>\n\t)\n}\n\nexport default App\n","import {configureStore} from '@reduxjs/toolkit'\nimport {gridSlice} from './grid/grid-slice'\nimport {shapesSlice} from './shapes/shapes-slice'\nimport {gameSlice} from './game/game-slice'\n\nexport const store = configureStore({\n\treducer: {\n\t\tgrid: gridSlice.reducer,\n\t\tshapes: shapesSlice.reducer,\n\t\tgame: gameSlice.reducer\n\t}\n})\n\nexport type RootState = ReturnType<typeof store.getState>\nexport type AppDispatch = typeof store.dispatch\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport {Provider} from 'react-redux'\nimport {store} from './state/store'\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}